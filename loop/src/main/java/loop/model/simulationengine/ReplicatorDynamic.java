package loop.model.simulationengine;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import loop.model.plugin.Parameter;
import loop.model.plugin.ParameterValidator;
import loop.model.plugin.Plugin;
import loop.model.simulationengine.PreferentialAdaption.PreferentialAdaptionPlugin;
import loop.model.simulationengine.distributions.UniformFiniteDistribution;
import loop.model.simulationengine.strategies.MixedStrategy;
import loop.model.simulationengine.strategies.Strategy;

/**
 * Realises the "replicator dynamic" adaption mechanism described in the specification.
 * 
 * @author Peter Koepernik
 *
 */
public class ReplicatorDynamic implements StrategyAdjuster {
    
    public static final String NAME = "Replicator Dynamic";
    private static final String DESCRIPTION = "At the end of an adaption step, each agent will consider changing his strategy with a certain,"
            + " configurable 'comparing probability'. If an agent, say A, chooses to do so, he randomly picks another agent B. He then compares"
            + " ranks, and if A is ranked higher then B, he keeps his strategy. Otherwise, he takes B's strategy with a probability p that"
            + " is proportional to the configurable 'adjusting probability' and the difference in ranks. If mixed strategies are used,"
            + " A does not simply take B's strategy but interpolates A's and B's strategies with parameter p.";
    
    private double alpha;
    private double beta;
    
    /**
     * Creates a new replicator dynamic instance with the given parameters.
     * 
     * @param alpha the comparing probability
     * @param beta the adjusting probability
     */
    public ReplicatorDynamic(double alpha, double beta) {
        if (alpha < 0 || alpha > 1 || beta < 0 || beta > 1) {
            throw new IllegalArgumentException("Invalid parameters for initialisation of replicator dynamic.");
        }
        
        this.alpha = alpha;
        this.beta = beta;
    }
    
    @Override
    public void adaptStrategies(List<Agent> agents, SimulationHistory history) {
        double beta_prime = this.beta / (agents.size() - 1);
        
        //check whether all strategies are mixed
        boolean allMixed = true;
        for (Agent agent: agents) {
            if (!(agent.getStrategy() instanceof MixedStrategy)) allMixed = false;
        }
        
        UniformFiniteDistribution<Agent> dist = new UniformFiniteDistribution<Agent>(agents);
        for (Agent agentA: agents) {
            Random r = new Random();
            if (r.nextDouble() > this.alpha) continue;
            
            //choose Agent B
            dist.removeObject(agentA);
            Agent agentB = dist.getPicker().pickOne();
            dist.addObject(agentA);
            
            int deltaR = agents.indexOf(agentA) - agents.indexOf(agentB);
            if (deltaR < 0) continue;
            
            //adapt strategy
            double delta = beta_prime * deltaR;
            if (allMixed) { //interpolate strategies
                MixedStrategy stratA = (MixedStrategy) agentA.getStrategy();
                MixedStrategy stratB = (MixedStrategy) agentB.getStrategy();
                
                List<Strategy> partStrats = new ArrayList<Strategy>(stratA.getComponentStrategies());
                List<Double> interpolationProbs = new ArrayList<Double>();
                for (Strategy s: partStrats) {
                    int index = partStrats.indexOf(s);
                    double probA = stratA.getComponent(index);
                    double probB = stratB.getComponent(index);
                    interpolationProbs.add(probA + delta * (probB - probA));
                }
                agentA.setStrategy(new MixedStrategy("--autogenerated--", "--autogenerated--", partStrats, interpolationProbs));
            } else { //take strategy with probability delta
                if (r.nextDouble() <= delta)
                    agentA.setStrategy(agentB.getStrategy());
            }
        }
    }
    
    /**
     * Returns a {@link Plugin} instance wrapping this implementation of the {@link StrategyAdjuster} interface.
     * 
     * @return a plugin instance.
     */
    public static Plugin<StrategyAdjuster> getPlugin() {
        if (plugin == null) {
            plugin = new ReplicatorDynamicPlugin();
        }
        return plugin;
    }
    
    private static ReplicatorDynamicPlugin plugin;
    
    private static class ReplicatorDynamicPlugin extends Plugin<StrategyAdjuster> {
        
        private List<Parameter> parameters = new ArrayList<Parameter>();
        
        public ReplicatorDynamicPlugin() {
            Parameter alphaParameter = new Parameter(0.0, 1.0, "comparing probability",
                    "The probability with which an agent considers to adapt his strategy at the end of an adaption step.");
            Parameter betaParameter = new Parameter(0.0, 1.0, "adjusting probability",
                    "A factor proportioning the probability (or the interpolation parameter) with which an agent takes the "
                    + "strategy of another agent after comparison.");
            parameters.add(alphaParameter);
            parameters.add(betaParameter);
        }
        
        @Override
        public String getName() {
            return NAME;
        }

        @Override
        public String getDescription() {
            return DESCRIPTION;
        }

        @Override
        public List<Parameter> getParameters() {
            return parameters;
        }

        @Override
        public StrategyAdjuster getNewInstance(List<Double> params) {
            if (!ParameterValidator.areValuesValid(params, parameters)) {
                throw new IllegalArgumentException("Invalid parameters given for the creation of a 'replicator dynamic' object");
            }
            return new ReplicatorDynamic(params.get(0), params.get(1));
        }
    }
    
}
