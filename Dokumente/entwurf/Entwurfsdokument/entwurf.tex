\documentclass[parskip=full,11pt]{scrartcl}

\usepackage[utf8]{inputenc}

%\title{Simulator für wiederholte Spiele}
%\author{Sebastian Feurer, Peter Koepernik, Luc Mercatoris,\\Christian Schorr, Pierre Toussing}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage{bbm}
\usepackage{amsmath} % for $\text{}$
\usepackage{amssymb}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float} % für Fließumgebungen; Platzierung H verschiebt nicht
\usepackage{multirow}
\restylefloat{figure}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\usepackage{pflichtenheft}

\usepackage[nonumberlist]{glossaries}

\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}

\begin{document}
\begin{titlepage}
	\centering
	\vspace*{5cm}
	\includegraphics[width = 0.7\linewidth]{images/Logos/loop.png}\par
	{\huge\bfseries Ein Simulator für wiederholte Spiele\par}
	%\vspace{1cm}
	{\Large Entwurfsdokument\par}
	\vspace{2cm}
	{\Large\itshape Sebastian Feurer, Peter Koepernik, Luc Mercatoris,\\Christian Schorr, Pierre Toussing\par}
	\vfill
	{\large \today\par}
\end{titlepage}

%\tableofcontents
%\pagebreak

\section{Einleitung}
TODO

\section{Spezifikationsänderungen}

\subsection{Populationen}
Das Konzept von Gruppen und Segmenten wurde überarbeitet. Die Gesamtheit der Gruppen, Segmente, sowie deren Größen und Einstellungen (bis auf Multikonfiguration) heißt nun eine \enquote{Population}. Die Konfiguration von Gruppen und Populationen wurde aus dem Konfigurationsfenster ausgelagert. Wie zur Strategie- und Stufenspielerstellung gibt es nun Fenster zur Erstellung einzelner Gruppen und Populationen.

\textbf{Gruppenerstellung:}
Im Gruppenerstellungsfenster können ein Name und eine Beschreibung der Gruppe eingetragen werden. Weiter können Anzahl und Größe von Segmenten sowie jeweils Strategie- und Kapitalverteilung eingestellt werden. Weiterhin kann eine Gruppe per Checkbox als \enquote{kohärent} deklariert werden (siehe \cref{?}). Diese Checkbox ist voreingestellt aktiviert. Wird sie deaktiviert, so identifizieren sich Agenten dieser Gruppe gegenseitig nicht mehr als Agenten derselben Gruppe. Diese Funktionalität realisiert das Konzept der \enquote{gruppenlosen Agenten}. Eine fertig konfigurierte Gruppe kann als Datei exportiert und eine als Datei exportierte Gruppe kann importiert werden.

\textbf{Populationserstellung:}
Im Populationserstellungsfenster können ein Name sowie eine Beschreibung der Population eingetragen werden. Dann können \(1\) bis \(16\) der selbst erstellten oder von vornherein im Programm hinterlegten Gruppen hinzugefügt werden. Für jede Gruppe können die Anzahl der Mitglieder über ein Textfeld eingegeben werden (siehe \cref{?}). Eine fertig konfigurierte Population kann als Datei exportiert und eine als Datei exportierte Population kann importiert werden.

Das Konfigurationsfenster ist nun nicht mehr in drei Bereiche unterteilt. Statt der Gruppeneinstellungen befindet sich nun zwischen den nun verschmolzenen, ehemaligen \enquote{Grund-} und \enquote{Erweiterten Einstellungen} nur noch ein Dropdown-Menü mit der Betitelung \enquote{Population} (siehe \cref{?}). Hier kann eine der selbst erstellten oder von vornherein im Programm hinterlegten Populationen ausgewählt werden. Unter dem Dropdown-Menü kann ein Abschnitt ausgeklappt werden, der die Zusammensetzung der Population zeigt (siehe \cref{?}). Dieser hat dieselbe Form wie die ehemaligen Gruppeneinstellungen, mit dem Unterschied, dass keine Modifikationen mehr vorgenommen werden können. Per Checkbox kann dort die \enquote{Multikonfiguration} für Segmente und Gruppen wie zuvor aktiviert werden.

\subsection{Strategien}
Die Liste aller Variablen, die in einer Strategie als Literal vorkommen können wurde um die folgenden erweitert:

\begin{itemize}
\item B hat bei bisherigen Spielen zwischen B und Agenten derselben Gruppenzugehörigkeit wie A (im aktuellen Adaptionsschritt) immer/nie/letztes Mal/wenigstens einmal kooperiert
\item B hat bei bisherigen Spielen zwischen B und Agenten mit ähnlichem aktuellen Kapital wie A (im aktuellen Adaptionsschritt) immer/nie/letztes Mal/wenigstens einmal kooperiert
\end{itemize}

\section{Pakete und Klassen}
\subsection{Paket \texttt{edu.kit.loop.model}}
Das Modell beinhaltet Klassen und Methoden zum Starten und Abbrechen von Simulationen, sowie zum Erstellen und Speichern von Konfigurationen, Stufenspielen, Strategien und Populationen.

\subsubsection{Class \texttt{UserConfiguration implements java.io.Serializable}}
//vielleicht im falschen Package

Diese Klasse repräsentiert eine vom Nutzer erstellte Konfiguration. Sie bietet Methoden zum Lesen aller zugehörigen Parameter.

Konstruktoren:

Methoden:
\begin{itemize}\itemsep -10pt
	\item \texttt{String getGameName()}
	\item[] Gibt den Namen des Stufenspiels dieser Konfiguration zurück.
	\item[] Returns: den Namen des Stufenspiels dieser Konfiguration
	
	\item \texttt{int getAgentCount()}
	\item[] Gibt die Anzahl von Agenten in dieser Konfiguration zurück.
	\item[] Returns: die Anzahl von Agenten in dieser Konfiguration
	
	\item \texttt{int getRoundCount()}
	\item[] Gibt die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration zurück.
	\item[] Returns: die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration
	
	\item \texttt{int getIterationCount()}
	\item[] Gibt die Anzahl der durchzuführenden Wiederholungen in dieser Konfiguration zurück.
	\item[] Returns: die Anzahl von Wiederholungen in dieser Konfiguration
	
	\item \texttt{List<String> getAvailableStrategyNames()}
	\item[] Gibt eine Liste der Namen von Strategien, die in der Konfiguration zugelassen sind zurück.
	\item[] Returns: eine Liste der Strategienamen
	
	\item \texttt{boolean getMixedAllowed()}
	\item[] Gibt zurück, ob in dieser Konfiguration gemischte Strategien zugelassen sind.
	\item[] Returns: \texttt{true}, falls in dieser Konfiguration gemischte Strategien zugelassen sind; \texttt{false} sonst
	
	\item \texttt{List<String> getPopulationNames()}
	\item[] Gibt eine Liste der Namen von Popultaionen, die in der Konfiguration ausgewählt sind zurück.
	\item[] Returns: eine Liste der Populationsnamen
	
	\item \texttt{String getPairBuilderName()}
	\item[] Gibt den Namen des  Paarbildungsalgorithmus dieser Konfiguration zurück.
	\item[] Returns: den Namen des Paarbildungsalgorithmus dieser Konfiguration
	
	\item \texttt{String getSuccessQuantifierName()}
	\item[] Gibt den Namen der Erfolgsquantifizierung dieser Konfiguration zurück.
	\item[] Returns: der Name der Erfolgsquantifizierung dieser Konfiguration
	
	\item \texttt{String getStrategyAdjusterName()}
	\item[] Gibt den Namen des Adaptionsmechanismus dieser Konfiguration zurück.
	\item[] Returns: den Namen des Adaptionsmechanismus dieser Konfiguration
	
	\item \texttt{List<double> getStrategyAdjusterParameters()}
	\item[] Gibt eine Liste der Werte der Parameter des \texttt{StrategyAdjuster}s zurück
	\item[] Returns: die Liste der Werte
	
	
	\item \texttt{String getEquilibriumCriterionName()}
	\item[] Gibt den Namen des  Gleichgewichtskriterium dieser Konfiguration zurück.
	\item[] Returns: den Namen des Gleichgewichtskriterium dieser Konfiguration
	
	\item \texttt{List<double> getEquilibriumParameters()}
	\item[] Gibt eine Liste der Werte der Parameter des \texttt{EquilibriumCriterion}s zurück
	\item[] Returns: die List der Werte
	
	\item \texttt{int getMaxAdapts()}
	\item[] Gibt die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration zurück.
	\item[] Returns: die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration
	
	\item \texttt{String getVariableParameterName()}
	\item[] Gibt den Namen des variablen Parameters zurück.
	\item[] Returns: den Namen des variablen Parameters
	
	\item \texttt{double getStartValue()}
	\item[] Gibt den Startwert des variablen Parameters zurück
	\item[] Returns: den Startwert des variablen Parameters
	
	\item \texttt{double getEndValue()}
	\item[] Gibt den Endwert des variablen Parameters zurück
	\item[] Returns: den Endwert des variablen Parameters
	
	\item \texttt{double getStepSize()}
	\item[] Gibt eie Schrittweite der Werte des variablen Parameters zurück
	\item[] Returns: die Schrittweite der Werte des variablen Parameters
	
	
\end{itemize}


\subsubsection{Class \texttt{Configuration}}
Diese Klasse repräsentiert die elementare Konfiguration einer einzelnen Wiederholung und enthält alle Informationen zum Start einer solchen:
\begin{itemize}\itemsep -10pt
\item Stufenspiel
\item Anzahl von Agenten
\item Runden pro Adaptionsschritt
\item Ob gemischte Strategien zugelassen sind
\item Gruppen-/Segmenteinteilungen
\item Kapital- und Strategieinitialisierung der Segmente
\item Agentenpaarung
\item Erfolgsquantifizierung
\item Adaptionsmechanismus
\item Gleichgewichtskriterium
\item Maximale Zahl von Adaptionsschritten
\end{itemize}

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Configuration(Game game, int roundCount, boolean mixedStrategies, Collection<Segment> segments, PairBuilder pairBuilder, SuccessQuantifier successQuantifier, SrategyAdjuster strategyAdjuster, EquilibriumCriterion equilibriumCriterion, int maxAdapts)}
\item[] Erstellt eine neue \texttt{Configuration} mit den gegebenen Parametern.
\item[] \texttt{game}: Das Stufenspiel dieser Konfiguration
\item[] \texttt{roundCount}: die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration
\item[] \texttt{mixedStrategies}: gibt an, ob gemischte Strategien in dieser Konfiguration erlaubt sind
\item[] \texttt{segments}: alle Segmente dieser Konfiguration
\item[] \texttt{pairBuilder}: Der Paarbildungsalgorithmus dieser Konfiguration
\item[] \texttt{successQuantifier}: die Erfolgsquantifizierung dieser Konfiguration
\item[] \texttt{strategyAdjuster}: der Adaptionsmechanismus dieser Konfiguration
\item[] \texttt{equilibriumCriterion}: das Gleichgewichtskriterium dieser Konfiguration
\item[] \texttt{maxAdapts}: die maximale Zahl durchzuführender Adaptionsschritte dieser Konfiguration
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Game getGame()}
\item[] Gibt das Stufenspiel dieser Konfiguration zurück.
\item[] Returns: das Stufenspiel dieser Konfiguration

\item \texttt{int getAgentCount()}
\item[] Gibt die Anzahl von Agenten in dieser Konfiguration zurück.
\item[] Returns: die Anzahl von Agenten in dieser Konfiguration

\item \texttt{int getRoundCount()}
\item[] Gibt die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration zurück.
\item[] Returns: die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration

\item \texttt{boolean allowsMixedStrategies()}
\item[] Gibt zurück, ob in dieser Konfiguration gemischte Strategien zugelassen sind.
\item[] Returns: \texttt{true}, falls in dieser Konfiguration gemischte Strategien zugelassen sind; \texttt{false} sonst

\item \texttt{Collection<Segment> getSegments()}
\item[] Gibt alle zu dieser Konfiguration gehörenden Segmente zurück.
\item[] Returns: eine \texttt{Collection} aller \texttt{Segment}e dieser Konfiguration

\item \texttt{PairBuilder getPairBuilder()}
\item[] Gibt den Paarbildungsalgorithmus dieser Konfiguration zurück.
\item[] Returns: den Paarbildungsalgorithmus dieser Konfiguration

\item \texttt{SuccessQuantifier getSuccessQuantifier()}
\item[] Gibt die Erfolgsquantifizierung dieser Konfiguration zurück.
\item[] Returns: die Erfolgsquantifizierung dieser Konfiguration

\item \texttt{StrategyAdjuster getStrategyAdjuster()}
\item[] Gibt den Adaptionsmechanismus dieser Konfiguration zurück.
\item[] Returns: den Adaptionsmechanismus dieser Konfiguration

\item \texttt{EquilibriumCriterion getEquilibriumCriterion()}
\item[] Gibt das Gleichgewichtskriterium dieser Konfiguration zurück.
\item[] Returns: das Gleichgewichtskriterium dieser Konfiguration

\item \texttt{int getMaxAdapts()}
\item[] Gibt die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration zurück.
\item[] Returns: die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration
\end{itemize}

\subsubsection{Inteface \texttt{Repository<T>}}

// Im falschen Paket

Ein Repository speichert eine Zuordnung von Namen und Entitäten und stellt diese auf Anfrage zur Verfügung.

Parameter:
\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} Der Typ der Entitäten, die in dem Depot gespeichert werden sollen
\end{itemize}


Methoden:
\begin{itemize}\itemsep -10pt
	\item \texttt{T getEntityByName(String name)}
	\item[] Gibt die zu dem Namen gehörige Entität zurück oder \texttt{null} falls das Depot keine Entität unter dem gegebene Namen speichert
	\item[] \texttt{name}: der Name der Entität die abgefragt werden soll
	\item[] Returns: die zu dem Namen gehörige Entität oder \texttt{null}
	
	\item \texttt{boolean addEntity(String name, T entity)}
	\item[] Fügt dem Depot eine neue Entität unter dem gegebene Namen hinzu
	\item[] \texttt{name}: der Name der Entität, die hinzugefügt werden soll
	\item[] \texttt{entity}: Die Entität, die hinzugefügt werden soll
	\item[] Returns: \texttt{true}, wenn die Entität erfolgreich hinzugefügt wurde und \texttt{false}, wenn bereits eine Entität unter dem Name im Depot existiert 
	
	\item \texttt{boolean containsEntityName(String name)}
	\item[] Gibt zurück, ob das Depot eine Entität unter dem gegebenen Namen enthält
	\item[] \texttt{name}: der Name der geprüft werden soll
	\item[] Returns: \texttt{true}, wenn das Depot eine Entität unter diesem Namen speichert und \texttt{false}, wenn nicht
	
\end{itemize}

\subsubsection{Class \texttt{HashMapRepository implements Repository<T>}}

// Im falschen Paket

Ein Implementierung des \texttt{Repository<T>}-Interface, die Entitäten in einer \texttt{HashMap} speichert.

Parameter:

\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} Der Typ der Entitäten, die in dem Depot gespeichert werden sollen
\end{itemize}

Konstruktoren:

\begin{itemize} \itemsep -10pt
	\item \texttt{HasMapRepository()}
	\item[] Erzeugt eine neue Instanz des Depots
\end{itemize}


\subsubsection{Class \texttt{FileIO}}

Diese Klasse stellt Funktionalitäten zum Laden und Speichern von Entitäten in Dateien zur Verfügung.

Methoden:

\begin{itemize}\itemsep -10pt
	\item \underline{\texttt{static <T> T loadEntity(File file)}}
	\item[] Lädt die Entität des Typs \texttt{T} aus der angegebenen Datei 
	\item[] \texttt{<T>} Entitätentyp der geladen werden soll
	\item[] \texttt{file}: Die Datei aus der die Entität geladen werden soll
	\item[]Returns: die geladenen Entität oder \texttt{null} wenn keine Entität des Typs \texttt{T} geladen werden konnte
	
	\item \underline{\texttt{static <T> List<T> loadAllEntities(File dir)}}
	\item[] Lädt alle Entität des Typs \texttt{T} aus den Dateien in dem gegebene Ordner 
	\item[] \texttt{<T>} Entitätentyp der geladen werden soll
	\item[] \texttt{dir}: Der Ordner aus dem die Entität geladen werden soll
	\item[]Returns: eine Liste aller geladener Entitäten des Typs \texttt{T}
	
	\item \underline{\texttt{static <T> List<T> loadAllEntities(List<File> files)}}
	\item[] Lädt alle Entität des Typs \texttt{T} aus den gegebenen Dateien
	\item[] \texttt{<T>} Entitätentyp der geladen werden soll
	\item[] \texttt{files}: Die Liste der Dateien aus denen die Entitäten geladen werden sollen
	\item[]Returns: eine Liste aller geladener Entitäten des Typs \texttt{T}
	
	\item \underline{\texttt{static <T> boolean saveEntity(File file, T entity)}}
	\item[] Speichert die Entität des Typs \texttt{T} in der gegebenen Datei
	\item[] \texttt{<T>} Entitätentyp der gespeichert werden soll
	\item[] \texttt{file}: Die Datei, in welche die Entität gespeichert werden soll
	\item[] \texttt{entity}: Die Entität die gespeichert werden soll
	\item[]Returns: \texttt{true}, wenn das Speichern erfolgreich war, andernfalls \texttt{false}
\end{itemize}


\subsubsection{Interface \texttt{Nameable}}

Implementierungen dieses Interface haben einen Namen und eine Beschreibung, die in Form von \texttt{String}s abgefragt werden können.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{String getName()}
\item[] Gibt den Namen des Objekts zurück.
\item[] Returns: den Namen des Objekts als \texttt{String}

\item \texttt{String getDescription()}
\item[] Gibt die Beschreibung des Objekts zurück.
\item[] Returns: die Beschreibung des Objekts als \texttt{String}
\end{itemize}

\subsubsection{Class \texttt{Population}}
Implements: \texttt{Nameable}

Diese Klasse repräsentiert eine Population. Sie bietet Methoden zur Abfrage von Größe und Gruppenzusammensetzung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Population(String name, String description, List<Group> groups, List<Integer> groupSizes)}
\item[] Erstellt eine neue Population mit Name, Beschreibung und Gruppenzusammensetzung wie gegeben.
\item[] \texttt{name}: der Name der Population
\item[] \texttt{description}: die Beschreibung der Population
\item[] \texttt{groups}: die Gruppen, aus denen diese Population besteht
\item[] \texttt{groupSizes}: die Größen der Gruppen in derselben Reihenfolge wie die zugehörigen Gruppen
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getSize()}
\item[] Gibt die Größe dieser Population zurück.
\item[] Returns: die Größe dieser Population

\item \texttt{List<Group> getGroups()}
\item[] Gibt die Gruppen zurück, aus denen diese Population besteht.
\item[] Returns: die Gruppen, aus denen diese Population besteht

\item \texttt{int getGroupSize(Group group)}
\item[] Gibt die Größe der gegebenen Gruppe zurück, falls sie Teil dieser Population ist; andernfalls \(0\).
\item[] \texttt{group}: die Gruppe, deren Größe zurückgegeben werden soll
\item[] Returns: die Größe der gegebenen Gruppe, falls sie Teil dieser Population ist; andernfalls \(0\)

\item \texttt{int getGroupCount()}
\item[] Gibt die Anzahl von Gruppen in dieser Population zurück.
\item[] Returns: die Anzahl von Gruppen in dieser Population
\end{itemize}

\subsubsection{Class \texttt{Group}}
Implements: \texttt{Nameable}

Diese Klasse repräsentiert eine Gruppe. Sie bietet Methoden zur Abfrage von Segmentzusammensetzung und Kohäsion.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Group(String name, String description, List<Segment> segments, List<Double> segmentSizes, boolean isCohesive)}
\item[] Erstellt eine neue Population mit Name, Beschreibung und Gruppenzusammensetzung wie gegeben.
\item[] \texttt{name}: der Name der Gruppe
\item[] \texttt{description}: die Beschreibung der Gruppe
\item[] \texttt{segments}: die Segmente, aus denen diese Gruppe besteht
\item[] \texttt{segmentSizes}: die relativen Größen der Segmente in derselben Reihenfolge wie die zugehörigen Segmente
\item[] \texttt{isCohesive}: gibt an, ob diese Gruppe kohärent ist
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Segment> getSegments()}
\item[] Gibt die Segmente zurück, aus denen diese Gruppe besteht.
\item[] Returns: die Segmente, aus denen diese Gruppe besteht

\item \texttt{double getSegmentSize(Segment segment)}
\item[] Gibt die Größe des gegebenen Segments zurück, falls es Teil dieser Gruppe ist; andernfalls \(0\).
\item[] \texttt{segment}: das Segment, dessen Größe zurückgegeben werden soll
\item[] Returns: die relative Größe des gegebenen Segments, falls es Teil dieser Gruppe ist; andernfalls \(0\)

\item \texttt{int getSegmentCount()}
\item[] Gibt die Anzahl von Segmenten in dieser Gruppe zurück.
\item[] Returns: die Anzahl von Segmente in dieser Gruppe

\item \texttt{boolean isCohesive()}
\item[] Gibt zurück, ob diese Gruppe kohärent ist.
\item[] Returns: \texttt{true}, falls diese Gruppe kohärent ist, \texttt{false} sonst
\end{itemize}

\subsubsection{Class \texttt{Segment}}

Diese Klasse repräsentiert ein Segment. Es bietet Methoden zur Abfrage von Kapital- und Strategieverteilung. Dabei werden lediglich die Namen der Kapitalverteilung sowie der verschiedenen Strategien gespeichert, die zu der entsprechenden \texttt{DiscreteDistribution} bzw. den entsprechenden \texttt{Strategy}s im zentralen Repository korrespondieren.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Segment(String capitalDistributionName, Collection<String> strategyNames)}
\item[] Erzeugt ein neues Segment mit gegebener Kapitalverteilung und gegebenen Strategien.
\item[] \texttt{capitalDistributionName}: der Name der Kapitalverteilung dieses Segments
\item[] \texttt{strategyNames}: die Namen der Strategien aus der Strategieverteilung dieses Segments
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{String getCapitalDistributionName()}
\item[] Gibt den Namen der Kapitalverteilung dieses Segments zurück.
\item[] Returns: den Namen der Kapitalverteilung dieses Segments

\item \texttt{Collection<String> getStrategyNames()}
\item[] Gibt die Namen der Strategien aus der Strategieverteilung dieses Segments zurück.
\item[] Returns: die Namen der Strategien aus der Strategieverteilung dieses Segments als \texttt{Collection<String>}
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.distribution}}

\subsubsection{Interface \texttt{Distribution<E>}}
Dieses Interface repräsentiert eine Wahrscheinlichkeitsverteilung über einem Träger von Objekten des Typs \texttt{E}. Eine Implementierung gibt auf Anfrage die Wahrscheinlichkeit eines bestimmten Objekts zurück und stellt einen \texttt{Picker<E>} zur Verfügung, mit dem zufällig Objekte aus der Wahrscheinlichkeitsverteilung gezogen werden können.

Methoden
\begin{itemize}\itemsep -10pt
\item \texttt{double getProbability(E object)}
\item[] Gibt die Wahrscheinlichkeit des gegebenen Objekts in dieser Verteilung zurück.
\item[] \texttt{element}: das Objekt, dessen Wahrscheinlichkeit abgefragt werden soll
\item[] Returns: die Wahrscheinlichkeit des gegebenen Objekts in dieser Verteilung

\item \texttt{Picker<E> getPicker()}
\item[] Gibt einen \texttt{Picker<E>} für diese Wahrscheinlichkeitsverteilung zurück.
\item[] Returns: einen \texttt{Picker<E>} für diese Wahrscheinlichkeitsverteilung
\end{itemize}

\subsubsection{Interface \texttt{Picker<E>}}
Ein \texttt{Picker<E>} wird von Implementierungen des \texttt{Distribution<E>}-Interfaces zur Verfügung gestellt, um Objekte aus der entsprechenden Wahrscheinlichkeitsverteilung zu ziehen.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{E pickOne()}
\item[] Zieht ein Objekt aus der Wahrscheinlichkeitsverteilung und gibt dieses zurück.
\item[] Returns: das aus der Wahrscheinlichkeitsverteilung gezogene Objekt

\item \texttt{Collection<E> pickMany(int i)}
\item[] Zieht mehrere Objekte aus der Wahrscheinlichkeitsverteilung und gibt diese als \texttt{Collection<E>} zurück.
\item[] \texttt{i}: die Anzahl der Objekte, die aus der Wahrscheinlichkeitsverteilung gezogen werden sollen
\item[] Returns: die aus der Wahrscheinlichkeitsverteilung gezogenen Objekte als \texttt{Collection<E>}
\end{itemize}

\subsubsection{Interface \texttt{DiscreteDistribution}}
Implements: \texttt{Distribution<Integer>}

Repräsentiert eine diskrete Wahrscheinlichkeitsverteilung auf den ganzen Zahlen. Eine Implementierung berechnet für einen gegebenen Wert \(q \in (0,1)\) ein Intervall \(I_q = [a,b]\) (\(a,b \in \mathbb{Z}, a < b\)), sodass ein zufällig gezogener Wert aus der Verteilung mindestens mit der Wahrscheinlichkeit \(q\) in \(I_q\) liegt. Die Grenzen dieses Intervalls können abgefragt werden.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getSupportMin(double q)}
\item[] Gibt die linke Grenze des Intervalls \(I_q\) zurück.
\item[] \texttt{q}: der Wert \(q\) zur Berechnung des Intervalls \(I_q\)
\item[] Returns: die linke Grenze des Intervalls \(I_q\)

\item \texttt{int getSupportMax(double q)}
\item[] Gibt die rechte Grenze des Intervalls \(I_q\) zurück.
\item[] \texttt{q}: der Wert \(q\) zur Berechnung des Intervalls \(I_q\)
\item[] Returns: die rechte Grenze des Intervalls \(I_q\)
\end{itemize}

\subsubsection{Class \texttt{PoissonDistribution}}
Implements: \texttt{DiscreteDistribution}

Repräsentiert eine Poisson-Verteilung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PoissonDistribution(double lambda)}
\item[] Erzeugt ein neues \texttt{PoissonDistribution}-Objekt mit dem Parameter \texttt{lambda}.
\item[] \texttt{lambda}: der variable Parameter in der Poissonverteilung
\end{itemize}

\subsubsection{Class \texttt{BinomialDistribution}}
Implements: \texttt{DiscreteDistribution}

Repräsentiert eine Bionomialverteilung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{BinomialDistribution(int a, int b, double p)}
\item[] Erzeugt ein neues \texttt{BinomialDistribution}-Objekt mit den gegebenen Parametern.
\item[] \texttt{a}: die linke Grenze der Verteilung
\item[] \texttt{b}: die rechte Grenze der Verteilung
\item[] \texttt{p}: der Wahrscheinlichkeitsparameter \(p \in [0,1]\) der Binomialverteilung
\end{itemize}

\subsubsection{Class \texttt{DiscreteUniformDistribution}}
Implements: \texttt{DiscreteDistribution}

Repräsentiert eine diskrete Gleichverteilung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{DiscreteUniformDistribution(int a, int b)}
\item[] Erzeugt ein neues \texttt{DiscreteUniformDistribution}-Objekt mit den gegebenen Parametern.
\item[] \texttt{a}: die linke Grenze der Verteilung
\item[] \texttt{b}: die rechte Grenze der Verteilung
\end{itemize}

\subsubsection{Interface \texttt{FiniteDistribution<E>}}
Extends: \texttt{Distribution<E>}

Repräsentiert eine Wahrscheinlichkeitsverteilung über Objekten des Typs \texttt{E} mit endlichem Träger. Implementierungen geben auf Abfrage den Träger als \texttt{Collection<E>} zurück.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Collection<E> getSupport()}
\item[] Gibt den Träger dieser Wahrscheinlichkeitsverteilung zurück.
\item[] Returns: den Träger dieser Wahrscheinlichkeitsverteilung als \texttt{Collection<E>}
\end{itemize}

\subsubsection{Class \texttt{UniformFiniteDistribution<E>}}
Implements: \texttt{FiniteDistribution<E>}

Repräsentiert eine Gleichverteilung über Objekten des Typs \texttt{E} mit endlichem Träger. Implementierungen bieten Methoden zum Hinzufügen und Entfernen von Objekten.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{UniformFiniteDistribution<E>()}
\item[] Erzeugt ein neues \texttt{UniformFiniteDistribution<E>}-Objekt mit leerem Träger.

\item \texttt{UniformFiniteDistribution<E>(Collection<E> ojects)}
\item[] Erzeugt ein neues \texttt{UniformFiniteDistribution<E>}-Objekt mit den gegebenen Objekten als Träger.
\item[] \texttt{objects}: die Objekte des Trägers dieser Wahrscheinlichkeitsverteilung
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void addObject(E object)}
\item[] Fügt das gegebene Objekt zum Träger hinzu.
\item[] \texttt{object}: das Objekt, das dem Träger hinzugefügt werden soll

\item \texttt{void addObjects(Collection<E> objects)}
\item[] Fügt die gegebenen Elemente zum Träger hinzu.
\item[] \texttt{objects}: die Objekte, die dem Träger hinzugefügt werden sollen

\item \texttt{boolean deleteObject(E object)}
\item[] Entfernt das gegebene Objekt aus dem Träger, falls enthalten.
\item[] \texttt{object}: das Objekt, das aus dem Träger entfernt werden soll
\item[] Returns: \texttt{true}, falls das gegebene Objekt im Träger enthalten war und entfernt wurde, andernfalls \texttt{false}
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.simulator}}
Dieses Paket enthält das Interface \texttt{Simulator}. Dieses bietet eine Schnittstelle zum Starten und Abbrechen von Simulationen. Beim Start einer Simulation wird eine Referenz auf ein \texttt{Simulation}-Objekt zurückgegeben, über das der Ausführungsstatus und die Ergebnisse der Simulation abgefragt werden können.

\subsubsection{Class \texttt{Simulation}}
Ein \texttt{Simulation}-Objekt enthält Informationen zu einer gestarteten Simulation, etwa deren Konfiguration, Ausführungsstatus, \texttt{id} und gegebenenfalls die Ergebnisse der Simulation. Es wird von einem \texttt{Simulator} erzeugt und bereitgestellt, wenn eine Simulation gestartet wird.

Die Klasse unterscheidet nicht zwischen Multikonfigurationen und Nicht-Multikonfigurationen, geht also allgemein von mehreren zugrundeliegenden elementaren Konfigurationen aus.

Konstruktoren:
\begin{itemize} \itemsep -10pt
\item \texttt{Simulation(UserConfiguration config, int id)}
\item[] Erzeugt ein neues \texttt{Simulation}-Objekt mit der gegebenen \texttt{UserConfiguration} und der gegebenen \texttt{id}.
\item[] \texttt{config}: die Konfiguration der Simulation
\item[] \texttt{id}: die \texttt{id} dieser Simulation
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{protected void addIterationResult(IterationResult result, int i)}
\item[] Fügt ein Wiederholungsergebnis zur \texttt{i}-ten elementaren Konfiguration dieser Simulation als \texttt{IterationResult} hinzu.
\item[] \texttt{result}: das Wiederholungsergebnis, das hinzugefügt werden soll
\item[] \texttt{i}: die elementare Konfiguration, zu der das Wiederholungsergebnis hinzugefügt werden soll

\item \texttt{void registerIterationFinished(Consumer<IterationResult> action)}
\item[] Registriert eine Aktion, die jedes mal ausgeführt wird, wenn eine Wiederholung dieser Simulation abgeschlossen wird. Der Aktion wird als Argument das Ergebnis der Wiederholung als \texttt{IterationResult} übergeben.
\item[] \texttt{action}: Die Aktion, die bei Abschluss jeder Wiederholung dieser Simulation ausgeführt werden soll

\item \texttt{List<IterationResult> getIterationResults(int i)}
\item[] Gibt eine Liste der Wiederholungsergebnisse der bisher abgeschlossenen Wiederholungen mit der \texttt{i}-ten zugrundeliegenden elementaren Konfiguration als \texttt{IterationResult}s zurück.
\item[] \texttt{i}: die elementare Konfiguration, zu der die Wiederholungsergebnisse zurückgegeben werden sollen
\item[] Returns: die Wiederholungsergebnisse der bisher abgeschlossenen Wiederholungen mit der \texttt{i}-ten zugrundeliegenden elementaren Konfiguration

\item \texttt{UserConfiguration getUserConfiguration()}
\item[] Gibt die \texttt{UserConfiguration} dieser Simulation zurück.
\item[] Returns: die \texttt{UserConfiguration} dieser Simulation

\item \texttt{int getConfigurationCount()}
\item[] Gibt die Zahl der dieser Simulation zugrundeliegenden elementaren Konfigurationen zurück. Im Falle einer Multikonfiguration also die Anzahl verschiedener Werte des Multikonfigurationsparameters, ansonsten \(1\).
\item[] Returns: die Zahl der dieser Simulation zugrundeliegenden elementaren Konfigurationen

\item \texttt{int getId()}
\item[] Gibt die \texttt{id} dieser Simulation zurück.
\item[] Returns: die \texttt{id} dieser Simulation
\end{itemize}

\subsubsection{Interface \texttt{Simulator}}
Über einen Simulator können Simulationen gestartet und abgebrochen werden. Zum Starten einer Simulation muss dem \texttt{Simulator} eine \texttt{UserConfiguration} übergeben werden, die die durchzuführende Simulation spezifiziert. Daraufhin wird ein \texttt{Simulation}-Objekt erzeugt und zurückgegeben, über das der Ausführungsstatus und die Ergebnisse der gestarteten Simulation abgefragt werden können. Jeder Simulation wird beim Start eine eindeutige \texttt{id} zugewiesen.

Methoden:
\begin{itemize} \itemsep -10pt
\item \texttt{Simulation startSimulation(UserConfiguration config)}
\item[] Startet eine Simulation mit der gegebenen \texttt{UserConfiguration} und gibt ein \texttt{Simulation}-Objekt zu der gestarteten Simulation zurück.
\item[]\texttt{config}: die Konfiguration, mit der die Simulation ausgeführt werden soll
\item[] Returns: ein \texttt{Simulation}-Objekt zu der gestarteten Simulation

\item \texttt{Simulation startSimulation(UserConfiguration config, Consumer<Simulation> action)}
\item[] Startet eine Simulation mit der gegebenen Konfiguration und gibt ein \texttt{Simulation}-Objekt zu der gestarteten Simulation zurück. Führt die gegebene Aktion mit der zurückgegebenen \texttt{Simulation} als Argument aus, sobald die Ausführung der Simulation abgeschlossen ist.
\item[] \texttt{config}: die Konfiguration, mit der die Simulation ausgeführt werden soll
\item[] \texttt{action}: Die Aktion, die ausgeführt werden soll, sobald die Simulation abgeschlossen ist
\item[] Returns: ein \texttt{Simulation}-Objekt zu der gestarteten Simulation

\item \texttt{boolean stopSimulation(Simulation sim)}
\item[] Falls die gegebene Simulation aktuell läuft, wird diese abgebrochen und \texttt{true} zurückgegeben. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{sim}: Die Simulation, die abgebrochen werden soll
\item[] Returns: \texttt{true}, wenn die Simulation erfolgreich abgebrochen wurde, \texttt{false} sonst

\item \texttt{boolean stopSimulation(int id)}
\item[] Falls eine Simulation mit der gegebenen \texttt{id} läuft, wird diese abgebrochen und \texttt{true} zurückgegeben. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{id}: Die \texttt{id} der Simulation, die abgebrochen werden soll
\item[] Returns: \texttt{true}, wenn die Simulation erfolgreich abgebrochen wurde, \texttt{false} sonst

\item \texttt{void stopAllSimulation()}
\item[] Bricht die Ausführung aller gestarteten Simulationen ab.

\item \texttt{Simulation getSimulation(int id)}
\item[] Gibt das \texttt{Simulation}-Objekt der Simulation mit der entsprechenden \texttt{id} zurück, falls existent. Ansonsten \texttt{null}.
\item[] \texttt{id}: Die \texttt{id} der Simulation, deren \texttt{Simulation}-Objekt zurückgegeben werden soll
\item[] Returns: das \texttt{Simulation}-Objekt der Simulation mit der entsprechenden \texttt{id}, falls existent. Ansonsten \texttt{null}.
\end{itemize}

\subsubsection{Class \texttt{ThreadPoolSimulator}}
Implements: \texttt{Simulator}

Eine Implementierung des \texttt{Simulator}-Interfaces. Führt die Wiederholungen parallel in einem \texttt{ThreadPool} aus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ThreadPoolSimulator()}
\item[] Erzeugt einen neuen \texttt{ThreadPoolSimulator}.

\item \texttt{ThreadPoolSimulator(int maxThreads)}
\item[] Erzeugt einen neuen \texttt{ThreadPoolSimulator} mit der gegebenen maximalen Anzahl von \texttt{Thread}s.
\item[] \texttt{maxThreads}: die maximale Anzahl von \texttt{Thread}s im \texttt{ThreadPool}
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getRunningIterationCount()}
\item[] Gibt die Zahl aktuell ausgeführter Wiederholungen zurück.
\item[] Returns: die Zahl aktuell ausgeführter Wiederholungen

\item \texttt{int getQueuedIterationCount()}
\item[] Gibt die Zahl aktuell auf Ausführung wartender Wiederholungen zurück.
\item[] Returns: die Zahl aktuell auf Ausführung wartender Wiederholungen
\end{itemize}

\subsubsection{Class \texttt{ConfigurationCreator}}
Diese Klasse nimmt eine \texttt{UserConfiguration} entgegen und extrahiert daraus alle zugehörigen elementaren Konfigurationen. Diese werden als \texttt{Configuration}s zurückgegeben.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ConfigurationCreator()}
\item[] Erzeugt einen neuen \texttt{ConfigurationCreator}.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Configuration> generateConfigurations(UserConfiguration config)}
\item[] Erzeugt alle zu der gegebenen \texttt{UserConfiguration} gehörigen elementaren Konfigurationen und gibt sie als \texttt{Configuration}s zurück.
\item[] \texttt{config}: Die \texttt{UserConfiguration}, zu der alle elementaren Konfigurationen generiert werden sollen
\item[] Returns: alle zu der gegebenen \texttt{UserConfiguration} gehörigen elementaren Konfigurationen als \texttt{Configuration}s
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.simulationengine}}

Dieses Paket beinhaltet die Klasse \texttt{SimulationEngine}, mit der eine einzelne Wiederholung zu einer bestimmten elementaren Konfiguration ausgeführt werden kann.

\subsubsection{Class \texttt{AgentInitializer}}
Ein \texttt{AgentInitializer} kann verwendet werden, um die Agenten eines gegebenen Segments zu erstellen und mit Kapital, Strategien und Gruppenzugehörigkeit zu initialisieren.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{AgentInitializer()}
\item[] Erzeugt einen neuen \texttt{AgentInitializer}.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Collection<Agent> initializeAgents(Segment segment)}
\item[] Erzeugt die Agenten des gegebenen Segments und initialisiert sie mit Kapital, Strategien und Gruppenzugehörigkeiten. Gibt die Agenten als \texttt{Collection} zurück.
\item[] Returns: die initialisierten Agenten als \texttt{Collection}
\end{itemize}

\subsubsection{Interface \texttt{SimulationHistory}}
Eine Implementierung des \texttt{SimulationHistory}-Interfaces speichert für jeden Agenten die Ergebnisse aller bisherigen Runden eines Adaptionsschrittes.

Methoden:
\begin{itemize}\itemsep -10pt
	\item \texttt{void addResult(GameResult result)}
	\item[] Fügt der Historie ein neues Rundenergebnis hinzu.
	\item[] \texttt{result}: Das \texttt{GameResult}, das zur Historie hinzugefügt werden soll
	\item \texttt{List<GameResult> getAllResults()}
	\item[]Gibt alle Rundenergebnisse  aller Agenten als Liste zurück.
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{List<GameResult> getResultsByAgent(agent: Agent)}
	\item[]Gibt alle Rundenergebnisse des gegebenen Agenten als Liste zurück.
	\item[] \texttt{agent}: Der Agent dessen Ergebnisse abgefragt werden
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{List<GameResult> getLatestResults()}
	\item[]Gibt das letzte Rundenergebnis aller Agenten als Liste zurück.
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{GameResult getLatestResultByAgent(agent: Agent)}
	\item[] Gibt das letzte Rundenergebnis des gegebenen Agenten zurück.
	\item[] \texttt{agent}: Der Agent dessen letztes Ergebnis abgefragt wird
	\item[]Returns: Das letzte RundenErgebnis des Agenten als \texttt{GameResult}
	\item \texttt{Iterable<GameResult> getAllWhere(condition: Predicate<GameResult>)}
	\item[] Filtert alle Rundenergebnisse gemäß einer gegebenen Filterbedingung und liefert sie in Form eines \texttt{Iterable} zurück.
	\item[]\texttt{condition}: Die Filterbedinung als Prädikat mit einem \texttt{GameResult} als Parameter.
	\item[]Returns: Die gefilterten Rundenergebnisse als \texttt{Iterable}
	\item \texttt{GameResult getLatestWhere(condition: Predicate<GameResult>)}
	\item[] Filtert alle Rundenergebnisse gemäß einer gegebenen Filterbedingung und liefert das letzte Rundenergebnis, welches die Bedingung erfüllt zurück.
	\item[]\texttt{condition}: Die Filterbedinung als Prädikat mit einem \texttt{GameResult} als Parameter.
	\item[]Returns: Das letzte Rundenergebnis, welches die Filterbedingung erfüllt
\end{itemize}

\subsubsection{Class \texttt{SimulationHistoryTable}}
Implements: \texttt{SimulationHistory}

Diese Klasse implementiert das \texttt{SimulationHistory}-Interface.

\subsubsection{Class \texttt{SimulationEngine}}

Diese Klasse bietet eine Methode zur Ausführung einer einzelnen Wiederholung zu einer gegebenen elementaren Konfiguration. Das Ergebnis wird in Form eines \texttt{IterationResult}-Objekts zurückgegeben.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{IterationResult executeIteration(Configuration configuration)}
\item[] Führt eine Wiederholung zu der gegebenen elementaren Konfiguration aus und gibt nach Abschluss das Ergebnis als \texttt{IterationResult} zurück.
\item[] \texttt{configuration}: die elementare Konfiguration, zu der die Wiederholung ausgeführt werden soll
\item[] Returns: das Ergebnis der Wiederholung als \texttt{IterationResult}
\end{itemize}

\subsubsection{Class \texttt{IterationResult}}
In einem Objekt dieser Klasse können die Ergebnisse einer durchgeführten Wiederholung gespeichert und abgefragt werden:
\begin{itemize}\itemsep -10pt
\item Die Agenten, geordnet nach Rang als \texttt{List<Agent>}
\item Der Verlauf des letzten Adaptionsschritts als \texttt{SimulationHistory}
\item Ob ein Gleichgewicht eingetreten ist
\item Die Effizienz des finalen Zustands
\item Die Zahl der durchgeführten Adaptionsschritte
\end{itemize}

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{IterationResult(List<Agent> agents, SimulationHistory history, boolean equilibriumReached, double efficiency, int adapts)}
\item[] Erzeugt ein neues \texttt{IterationResult}-Objekt mit den gegebenen Simulationsergebnissen.
\item[] \texttt{agents}: die Agenten der Simulation, geordnet nach finalem Rang
\item[] \texttt{history}: der Verlauf des letzten Adaptionsschritts
\item[] \texttt{equilibriumReached}: \texttt{true}, falls ein Gleichgewicht erreicht wurde, \texttt{false} sonst
\item[] \texttt{efficiency}: die Effizienz des finalen Zustands
\item[] \texttt{adapts}: die Zahl durchgeführter Adaptionsschritte
\end{itemize}

Methoden
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> getAgents()}
\item[] Gibt die Agenten der Simulation zurück, geordnet nach finalem Rang
\item[] Returns: die Agenten der Simulation, geordnet nach finalem Rang

\item \texttt{SimulationHistory getHistory()}
\item[] Gibt den Verlauf des finalen Adaptionsschrittes zurück
\item[] Returns: den Verlauf des finalen Adaptionsschrittes als \texttt{SimulationHistory}

\item \texttt{boolean equilibriumReached()}
\item[] Gibt zurück, ob sich ein Gleichgewicht eingestellt hat.
\item[] Returns: \texttt{true}, fallss sich ein Gleichgewicht eingestellt hat, \texttt{false} sonst

\item \texttt{double getEfficiency()}
\item[] Gibt die Effizienz des finalen Zustands zurück.
\item[] Returns: die Effizienz des finalen Zustands

\item \texttt{int getAdapts()}
\item[] Gibt die Zahl durchgeführter Adaptionsschritte zurück.
\item[] Returns: die Zahl durchgeführter Adaptionsschritte
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.simulationengine.core}}
Dieses Paket beinhaltet für den Simulationsablauf zentrale Klassen wie den \texttt{Agent}, das Stufenspiel (\texttt{Game}) oder die \texttt{Strategy}.

\subsubsection{Class \texttt{Agent}}
Diese Klasse repräsentiert einen einzelnen Agenten in einem Simulationsdurchlauf. Sie enthält Informationen über den Agenten wie dessen Gruppenzugehörigkeit, sein aktuelles und initiales Kapital oder seine aktuelle Strategie.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Agent(int initialCapital, Strategy initialStrategy, int groupId)}
\item[] Erstellt einen neuen Agenten mit gegebenem Anfangskapital, gegebener Strategie und gegebener Gruppenzugehörigkeit
\item[] \texttt{initialCaptial}: das initiale Kapital des Agenten
\item[] \texttt{initialStrategy}: die initiale Strategie des Agenten
\item[] \texttt{groupId}: die \texttt{id} der Gruppe, der dieser Agent zugehörig ist; \(-1\), falls dieser Agent gruppenlos ist.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getCapital()}
\item[] Gibt das aktuelle Kapital des Agenten zurück.
\item[] Returns: das aktuelle Kapital des Agenten

\item \texttt{int getInitialCapital()}
\item[] Gibt das initiale Kapital des Agenten zurück.
\item[] Returns: das initiale Kapital des Agenten

\item \texttt{void addCapital(int capital)}
\item[] Erhöht das Kapital des Agenten um den gegebenen Wert.

\item \texttt{Strategy getStrategy()}
\item[] Gibt die aktuelle Strategie des Agenten zurück.
\item[] Returns: die aktuelle Strategie des Agenten

\item\texttt{void setStrategy(Strategy strategy)}
\item[] Setze die Strategie des Agenten auf die gegebene Strategie.

\item \texttt{int getGroupId()}
\item[] Gibt die \texttt{id} der Gruppe zurück, der dieser Agent zugehörig ist bzw. \(-1\) falls er gruppenlos ist.
\item[] Returns: die \texttt{id} der Gruppe zurück, der dieser Agent zugehörig ist bzw. \(-1\) falls er gruppenlos ist.
\end{itemize}

\subsubsection{Interface \texttt{AgentPair}}
Dieses Interface repräsentiert ein Paar von Agenten.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{getFirstAgent()}
\item[] Gibt den ersten der beiden Agenten zurück.
\item[] Returns: den ersten der beiden Agenten

\item \texttt{getSecondAgent()}
\item[] Gibt den zweiten der beiden Agenten zurück.
\item[] Returns: den zweiten der beiden Agenten
\end{itemize}

\subsubsection{Class \texttt{GameResult}}

Diese Klasse speichert das Ergebnis eines Spiels zwischen zwei Agenten. Das Ergebnis besteht aus:
\begin{itemize}\itemsep -10pt
	\item Den beteiligten Agenten
	\item Den Aktionen der beteiligten Agenten
	\item Den erhaltenen Auszahlungen der Agenten
\end{itemize}
	
Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{GameResult(Agent player1, Agent player2, int payOff1, int payOff2, boolean hasCooperated1, boolean hasCooperated2)}
\item[] Erzeugt ein neues \texttt{GameResult}-Objekt.
\item[] \texttt{player1}: der erste Spieler
\item[] \texttt{player2}: der zweite Spieler
\item[] \texttt{payOff1}: die erhaltene Auszahlung des ersten Spielers
\item[] \texttt{payOff2}: die erhaltene Auszahlung des zweiten Spielers
\item[] \texttt{hasCooperated1}: \texttt{true}, falls der erste Spieler kooperiert hat; \texttt{false} sonst
\item[] \texttt{hasCooperated2}: \texttt{true}, falls der zweite Spieler kooperiert hat; \texttt{false} sonst
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item  \texttt{boolean hasAgent(Agent agent)}
\item[] Gibt zurück, ob der gegebene Agent einer der beiden Spieler dieses Spiels war.
\item[] \texttt{agent}: der Agent, für den geprüft werden soll, ob er Spieler dieses Spiels war
\item[] Returns: \texttt{true}, falls der gegebene Agent einer der beiden Spieler dieses Spiels war; \texttt{false} sonst

\item \texttt{int getPayoff(Agent agent)}
\item[] Gibt die Auszahlung zurück, die der gegebene Agent bei diesem Spiel erhalten hat, falls er beteiligt war; andernfalls wird \(0\) zurückgegeben.
\item[] \texttt{agent}: der Agent, dessen Auszahlung zurückgegeben werden soll
\item[] Returns: die erhaltene Auszahlung des gegebenen Agenten, falls er beteiligt war; andernfalls \(0\)

\item \texttt{boolean hasCooperated(Agent agent)}
\item[] Gibt zurück, ob der gegebene Agent in diesem Spiel kooperiert hat, falls er beteiligt war. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{agent}: der Agent, für den zurückgegeben werden soll, ob er kooperiert hat
\item[] Returns: \texttt{true}, falls der gegebene Agent an diesem Spiel beteiligt war und kooperiert hat, andernfalls \texttt{false}

\item \texttt{Collection<Agent> getAgents()}
\item[] Gibt die beiden an diesem Spiel beteiligten Agenten zurück.
\item[] Returns: die beiden an diesem Spiel beteiligten Agenten als \texttt{Collection<Agent>}
\end{itemize}

\subsubsection{Interface \texttt{Game}}
Extends: \texttt{Nameable}

Dieses Interface repräsentiert ein Stufenspiel.

Methoden:
\begin{itemize}\itemsep -10pt
\item[] \texttt{GameResult play(boolean playerOneCooperates, boolean playerTwoCooperates)}
\item[] Lässt zwei Spieler mit gegebenen Kooperationsentscheidungen dieses Stufenspiel spielen und gibt das Ergebnis des Spiels als \texttt{GameResult}-Objekt zurück.
\item[] \texttt{playerOneCooperates}: \texttt{true}, falls der erste Spieler kooperiert; \texttt{false sonst}
\item[] \texttt{playerTwoCooperates}: \texttt{true}, falls der zweite Spieler kooperiert; \texttt{false sonst}
\item[] Returns: das Ergebnis des Spiels als \texttt{GameResult}-Objekt
\end{itemize}

\subsubsection{Interface \texttt{Strategy}}
Extends: \texttt{Nameable}

Repräsentiert eine Strategie. Diese kann, muss aber nicht gemischt sein.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{boolean isCooperative(Agent player, Agent opponent, SimulationHistory history)}
\item[] Gibt zurück, ob der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde. Ist die Strategie gemischt, wird entsprechend ein zufälliges Ergebnis ausgegeben.
\item[] Returns: ob der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde

\item \texttt{double getCooperationProbability(Agent player, Agent opponent, SimulationHistory history)}
\item[] Gibt die Wahrscheinlichkeit zurück, mit der der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde.
\item[] Returns: die Wahrscheinlichkeit, mit der der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde
\end{itemize}

\subsubsection{Class \texttt{PureStrategy}}
Implements: \texttt{Strategy}

Diese Klasse repräsentiert eine reine Strategie. Diese ist eindeutig bestimmt durch eine Bedingung an den gegnerischen Agenten basierend auf dem bisherigen Verlauf der Simulation, repräsentiert als \texttt{Predicate<Agent,SimulationHistory>}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PureStrategy(Predicate<Agent,SimulationHistory> condition)}
\item[] Erzeugt ein neues \texttt{PureStrategy}-Objekt.
\item[] \texttt{condition}: die Bedingung an den gegnerischen Agenten, unter der ein Agent bei Verwendung dieser Strategie kooperiert
\end{itemize}

\subsubsection{Class \texttt{CustomStrategy}}
//vorläufig

\subsubsection{Class \texttt{MixedStrategy}}
Implements: \texttt{Strategy}

Diese Klasse repräsentiert eine gemischte Strategie, die sich aus mehreren \texttt{PureStrategie}s zusammensetzt.

Konstruktoren://vorläufig
\begin{itemize}\itemsep -10pt
\item[] //wirft exception wenn listen nicht gleichlang oder wahrsch. ungültig (alle positiv und in summe 1)
\item \texttt{MixedStrategy(List<PureStrategies> pureStrategies, List<Integer> probabilites)}
\item[] Erstellt eine neue \texttt{MixedStrategy}, die aus den gegebenen reinen Strategien mit den gegebenen Wahrscheinlichkeiten besteht.
\item[] \texttt{pureStrategies}: die reinen Strategien, aus denen diese Strategie besteht
\item[] \texttt{probabilities}: die Wahrscheinlichkeiten der gegebenen reinen Strategien
\end{itemize}

\subsubsection{Class \texttt{Segment}}
//umbenennen!
Diese Klasse repräsentiert ein Segment. Dieses wird charakterisiert durch die Anzahl zugehöriger Agenten, die \texttt{id} der Gruppe, zu der das Segment gehört sowie initiale Kapital- und Strategieverteilung.

Konstruktoren:

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getAgentCount()}
\item[] Gibt die Anzahl der Agenten in diesem Segment zurück.
\item[] Returns: die Anzahl der Agenten in diesem Segment

\item \texttt{int getGroupId()}
\item[] Gibt die \texttt{id} der Gruppe zurück, zu der dieses Segment gehört bzw. \(-1\), falls es zu den gruppenlosen Agenten gehört.
\item[]die \texttt{id} der Gruppe, zu der dieses Segment gehört bzw. \(-1\), falls es zu den gruppenlosen Agenten gehört

\item \texttt{DiscreteDistribution getCapitalDistribution()}
\item[] Gibt die Kapitalverteilung dieses Segments zurück
\item[] Returns: die Kapitalverteilung dieses Segments als \texttt{DiscreteDistribution}

\item \texttt{UniformFiniteDistribution<Strategy> getStrategyDistribution()}
\item[] Gibt die Strategieverteilung dieses Segments zurück
\item[] Returns: die Strategieverteilung dieses Segments als \texttt{UniformFiniteDistribution<Strategy>}
\end{itemize}

\subsubsection{Interface \texttt{PairBuilder}}
Dieses Interface repräsentiert einen Paarbildungsalgorithmus. Eine Implementierung nimmt eine Menge von Agenten sowie den bisherigen Verlauf des aktuellen Adaptionsschritts in Form eines \texttt{SimulationHistory}-Objektes entgegen und gibt ein Matching der Agenten zurück.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Collection<AgentPair> buildPairs(Collection<Agent> agents, SimulationHistory history)}
\item[] Fasst die gegebene Menge von Agenten zu Paaren zusammen und gibt diese als \texttt{Collection} von \texttt{AgentPair}s zurück.
\item[] \texttt{agents}: die Agenten, aus denen Paare gebildet werden sollen
\item[] \texttt{history}: der bisherige Verlauf des Adaptionsschritts
\item[] Returns: die gebildeten Paare als \texttt{Collection<AgentPair>}
\end{itemize}

\subsubsection{Class \texttt{RandomPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die zufällige Paarbildung von Agenten.

\subsubsection{Class \texttt{CooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die in der Spezifikation beschriebene \enquote{Paarbildung nach Wunsch}.

\subsubsection{Class \texttt{RandomCooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die in der Spezifikation beschriebene \enquote{Paarbildung nach Wunsch mit Zufall}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{RandomCooperationConsideringPairBuilder(double randomnessFactor)}
\item[] Erstellt einen neuen \texttt{RandomCooperationConsideringPairBuilder}.
\item[] \texttt{randomnessFactor}: der Zufallsfaktor für die Paarbildung; zwischen \(0\) und \(1\)
\end{itemize}

\subsubsection{Interface \texttt{SuccessQuantifier}}
Dieses Interface repräsentiert eine Erfolgsquantifizierung. Eine Implementierung nimmt eine Menge von Agenten sowie den bisherigen Verlauf des aktuellen Adaptionsschritts in Form eines \texttt{SimulationHistory}-Objektes entgegen und erstellt eine Rangliste der Agenten anhand deren Erfolg in den vergangenen Runden. Diese wird als Liste zurückgegeben.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> createRanking(Collection<Agent> agents, SimulationHistory history)}
\item[] Erstellt eine Rangliste der gegebenen Agenten und gibt diese als Liste zurück.
\item[] \texttt{agents}: die Agenten, aus denen eine Rangliste erstellt werden soll
\item[] \texttt{history}: der bisherige Verlauf des aktuellen Adaptionsschritts
\item[] Returns: die erstellte Rangliste als \texttt{List<Agent>}
\end{itemize}

\subsubsection{Class \texttt{TotalCapital}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Absolutkapital}-Erfolgsquantifizierung

\subsubsection{Class \texttt{TotalPayoff}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Absolutkapital ohne Initialkapital}-Erfolgsquantifizierung.

\subsubsection{Class \texttt{SlidingMean}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Gleitender Durchschnitt}-Erfolgsquantifizierung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{SlidingMean(int windowSize)}
\item[] Erstellt ein neues \texttt{SlidingMean}-Objekt mit der gegebenen Fenstergröße.
\item[] \texttt{windowSize}: die Fenstergröße für die Durchschnittsberechnung
\end{itemize}

\subsubsection{Class \texttt{PayoffInLastAdapt}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Auszahlung im letzten Adaptionsschritt}-Erfolgsquantifizierung.

\subsubsection{Interface \texttt{StrategyAdjuster}}
Dieses Interface repräsentiert einen Adaptionsmechanismus. Eine Implementierung nimmt eine nach Rang geordnete Liste von Agenten entgegen und passt die Strategien der Agenten an.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void adaptStrategies(List<Agent> agents)}
\item[] Adaptiert die Strategien der gegebenen Agenten.
\item[] \texttt{agents}: die Agenten, deren Strategien adaptiert werden sollen, geordnet nach Erfolg im aktuellen Adaptionsschritt
\end{itemize}

\subsubsection{Class \texttt{ReplicatorDynamic}}
Implements: \texttt{StrategyAdjuster}

Realisiert den in der Spezifikation beschriebenen \enquote{Replicator Dynamic}-Anpassungsmechanismus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ReplicatorDynamic(double alpha, double delta)}
\item[] Erstellt ein neues \texttt{ReplicatorDynamic}-Objekt mit den gegebenen Parametern \(\alpha\) und \(\delta\).
\item[] \texttt{alpha}: die Vergleichswahrscheinlichkeit
\item[] \texttt{delta}: die Anpassungswahrscheinlichkeit
\end{itemize}

\subsubsection{Class \texttt{PreferentialAdaption}}
Implements: \texttt{StrategyAdjuster}

Realisiert den in der Spezifikation beschriebenen \enquote{Preferential Adaption}-Anpassungsmechanismus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PreferentialAdaption(double alpha, double delta)}
\item[] Erstellt ein neues \texttt{PreferentialAdaption}-Objekt mit den gegebenen Parameter \(\alpha\) und \(\delta\).
\item[] \texttt{alpha}: die Vergleichswahrscheinlichkeit
\item[] \texttt{delta}: die Anpassungswahrscheinlichkeit
\end{itemize}

\subsubsection{Interface \texttt{EquilibriumCriterion}}
Dieses Interface repräsentiert ein Gleichgewichtskriterium. Eine Implementierung nimmt am Ende eines Adaptionsschritts eine Liste der Agenten, geordnet nach Rang, sowie den Verlauf des Adaptionsschritts in Form eines \texttt{SimulationHistory}-Objektes entgegen und gibt zurück, ob sich ein Gleichgewicht eingestellt hat.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{boolean isEquilibrium(List<Agent> agents, SimulationHistory history)}
\item[] Gibt zurück, ob sich ein Gleichgewicht eingestellt hat.
\item[] \texttt{agents}: die Agenten des aktuellen Simulationslaufs
\item[] \texttt{history}: der Verlauf des aktuellen Adaptionsschritts
\item[] Returns: \texttt{true}, falls sich ein Gleichgewicht eingestellt hat, \texttt{false} sonst
\end{itemize}

\subsubsection{Abstract Class \texttt{CountingEquilibriumCriterion}}
Implements: \texttt{EquilibriumCriterion}

Diese Klasse repräsentiert ein Gleichgewichtskriterium, dass jede Runde eine bestimmte Bedingung prüft und ein Gleichgewicht erkennt, wenn diese Bedingung für eine bestimmte Zahl aufeinanderfolgender Adaptionsschritte erfüllt ist. Diese Bedingung und die nötige Zahl aufeinanderfolgender Adaptionsschritte sind als Schablonenmethoden implementiert.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{abstract boolean hasEquilibriumCondition(List<Agent> agents, SimulationHistory history)}
\item[] Gibt zurück, ob die Gleichgewichtsbedingung für diesen Adaptionsschritt erfüllt ist.
\item[] \texttt{agents}: die Agenten des aktuellen Simulationslaufs
\item[] \texttt{history}: der Verlauf des aktuellen Adaptionsschritts
\item[] Returns: \texttt{true}, falls die Bedingung erfüllt ist, \texttt{false} sonst

\item \texttt{abstract boolean longEnough(int steps)}
\item[] Gibt zurück, ob \texttt{steps} größer oder gleich der nötigen Zahl aufeinanderfolgender Gleichgewichtsbedingung-erfüllender Adaptionsschritte ist.
\item[] \texttt{steps}: die Anzahl von Adaptionsschritten, für die geprüft werden soll, ob sie in obigem Sinne hinreichend groß ist
\item[] Returns: \texttt{true}, falls \texttt{steps} groß genug ist, \texttt{false} sonst
\end{itemize}

\subsubsection{Class \texttt{StrategyEquilibrium}}
Implements: \texttt{CountingEquilibriumCriterion}

Realisiert das in der Spezifikation beschriebene \enquote{Strategie-Gleichgewichtskriterium}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{StrategyEquilibrium(double alpha, int G)}
\item[] Erzeugt ein neues \texttt{StrategyEquilibrium}-Objekt mit den gegebenen Parametern.
\item[] \texttt{alpha}: die Strenge des Gleichgewichts
\item[] \texttt{G}: die minimale Zahl aufeinanderfolgender Gleichgewichtsbedingung-erfüllender Adaptionsschritte
\end{itemize}

\subsubsection{Class \texttt{RankingEquilibrium}}
Implements: \texttt{CountingEquilibriumCriterion}

Realisiert das in der Spezifikation beschriebene \enquote{Rang-Gleichgewichtskriterium}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{RankingEquilibrium(double alpha, int G)}
\item[] Erzeugt ein neues \texttt{RankingEquilibrium}-Objekt mit den gegebenen Parametern.
\item[] \texttt{alpha}: die Strenge des Gleichgewichts
\item[] \texttt{G}: die minimale Zahl aufeinanderfolgender Gleichgewichtsbedingung-erfüllender Adaptionsschritte
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.Controller}}
Dieses Paket enthält die Kontrollstruktur des Programms und dient als Verbindung zwischen dem View und dem Model.
Die einzelnen Kontroller sind in einer baumartigen Struktur angeordnet und die Wurzel ist der \enquote{Headcontroller}. Dieser dient als Schnittstelle zwischen dem Model und dem Rest der Kontrollstruktur.

\subsubsection{Class \texttt{HeadController}}
Diese Klasse repräsentiert die Schnittstelle zwischen dem Model und dem Rest der Kontrollstruktur. Sie kann dem Simulator eine neue Konfiguration in Auftrag geben, Populationen zum abspeichern übergeben oder eine abgespeicherte Konfiguration erneut öffnen.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{CentralController(Simulator simulator, ConfigurationParameterRepository repository)}
\item[] Erstellt einen neuen HeadController, sichert die Referenz auf den Simulator und lädt das übergebene Repository.
\item[] \texttt{simulator}: der Simulator der die Simulationen mit gegebener Konfiguration startet
\item[] \texttt{repository}: Repository, das die verschiedenen Strategien, Paarungsalgorithmen und die weiteren verfügbaren Einstellungsmöglichkeiten enthält
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void setConfiguration(Configuration)}
\item[] Stellt eine Configuration im Kontroller ein


\item \texttt{Configuration getConfiguration()}
\item[] Gibt die aktuell eingestellte Konfiguration zurück
\item[] Returns: die aktuell eingestellte Konfiguration

\item \texttt{void addSimulationToHistory(Simulation)}
\item[] Fügt eine neue Simulation in die Simulationshistorie hinzu

\item \texttt{void saveStrategy(Strategy strategy)}
\item[] Speichert die ausgewählte Strategie ab.

\item\texttt{void saveGame(Game stufenspiel)}
\item[] Speichert das ausgewählte Stufenspiel ab

\item \texttt{void saveConfiguration(Configuration configuration)}
\item[] Speichert die ausgewählte Konfiguration an einem gewünschten Ort ab

\item \texttt{void savePopulation(Population population)}
\item[] Speichert die ausgewählte Population ab

\item \texttt{void saveGroup(Group group)}
\item[] Speichert die ausgewählte Gruppe ab

\item \texttt{void updateSimulation(Simulation simulation)}
\item[] Updatet den Fortschritt einer gewünschten Simulation

\item \texttt{void runConfiguration(Configuration configuration}
\item[] Gibt dem Simulator den Befehl eine neue Simulation mit der ausgewählten Konfiguration zu starten
\end{itemize}

\subsubsection{Class \texttt{MainController}}
Diese Klasse repräsentiert den Kontroller der für das Hauptfenster zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{MainController()}
\item[] Erstellt einen neuen MainController
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void setConfiguration(Configuration)}
\item[] Stellt eine Configuration im Kontroller ein


\item \texttt{void configure()}
\item[] Öffnet das Konfigurationsfenster

\item \texttt{void addSimulationToHistory(Simulation)}
\item[] Fügt eine neue Simulation in die Simulationshistorie hinzu

\item \texttt{void updateSimulation(Simulation simulation)}
\item[] Updatet den Fortschritt einer gewünschten Simulation
\end{itemize}

\subsubsection{Class \texttt{BasicsController}}
Diese Klasse repräsentiert den Kontroller der für die Basisansicht im Hauptfenster zuständig ist.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void setConfiguration(Configuration)}
\item[] Stellt eine Configuration im Kontroller ein


\item \texttt{void configure()}
\item[] Öffnet das Konfigurationsfenster
\end{itemize}

\subsubsection{Class \texttt{GraphicController}}
Diese Klasse repräsentiert den Kontroller der für die Ergebnisausgabe im Hauptfenster zuständig ist.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void showSimulation(Simulation simulation)}
\item[] Zeigt die Ergebnisse für die ausgewählte Simulation an

\item \texttt{void repaint()}
\item[] Zeichnet die Graphen und Diagramme auf der ausgewählten Seite mit den neuen Werten


\item \texttt{void updateValues()}
\item[] Updatet alle im Fenster verstellbaren Parameter

\item \texttt{void setPageNumber(int page)}
\item[] Stellt die Seitenzahl auf der der Benutzer sich gerade befindet ein
\end{itemize}


\subsubsection{Class \texttt{HistoryController}}
Diese Klasse repräsentiert den Kontroller der für die Simulationshistorie zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{HistoryController()}
\item[] Erstellt einen neuen HistoryController
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void addSimulationToHistory(Simulation)}
\item[] Fügt eine neue Simulation in die Simulationshistorie hinzu

\item \texttt{void updateSimulationProgress(Simulation simulation)}
\item[] Updatet den Fortschritt einer gewünschten Simulation
\end{itemize}

\subsubsection{Class \texttt{MenuController}}
Diese Klasse repräsentiert den Kontroller der für das Menu zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{MenuController(Repository<t> repository)}
\item[] Erstellt einen neuen MenuController und dieser erhält das Repository mit allen verfügbaren Plugins
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void saveconfiguration(Configuration configuration)}
\item[] Speichert die gewünschte Konfiguration ab

\item \texttt{void loadConfiguration()}
\item[] Öffnet ein Dialogfenster in dem der Benutzer eine abgespeicherte Konfiguration zum öffnen auswählen kann

\item \texttt{void addGame()}
\item[] Öffnet das \enquote{Neues Stufenspiel erstellen}-Fenster

\item \texttt{void addStrategy()}
\item[] Öffnet das \enquote{Neue Strategy erstellen}-Fenster

\item \texttt{void addPopulation()}
\item[] Öffnet das \enquote{Neue Population erstellen}-Fenster

\item \texttt{void addGroup()}
\item[] Öffnet das \enquote{Neue Gruppe erstellen}-Fenster

\item \texttt{void close()}
\item[] Schließt das Fenster

\item \texttt{void runConfiguration(Configuration configuration}
\item[] Gibt dem HeadController den Befehl eine neue Simulation mit der ausgewählten Konfiguration zu starten

\item \texttt{void help()}
\item[] Zeigt die Hilfe für den Benutzer an
\end{itemize}

\subsubsection{Class \texttt{GroupController}}
Diese Klasse repräsentiert den Kontroller der für das \enquote{Neue Gruppe erstellen}-Fenster zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Groupcontroller(Repository<t> repository)}
\item[] Erstellt einen neuen GroupController und dieser erhält das Repository mit allen verfügbaren Plugins
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void addSegment(}
\item[] Fügt der Gruppe ein neues Segment hinzu

\item \texttt{void deleteSegment(String segmentId)}
\item[] Löscht eine über einen String klar definierbares Segment aus der Gruppe

\item \texttt{void setSegmentSize(String segmentId, int size)}
\item[] Setzt die Grösse des ausgewählten Segments auf die angegebene Anzahl an Agenten

\item \texttt{int getSegmentSize(String segmentId)}
\item[] Gibt die Grösse des ausgewählten Segments zurück
\item[] Returns: die Anzahl an Agenten des ausgewählten Segments

\item \texttt{String getGroupName()}
\item[] Gibt den Namen der aktuellen Gruppe zurück
\item[] Returns: der Name der aktuell ausgewählten Gruppe

\item \texttt{void setGroupName(String name)}
\item[] Setzt den Namen der Gruppe auf den vom Nutzer eingegebenen Namen

\item \texttt{String getGroupDescription()}
\item[] Gibt die Beschreibung der aktuellen Gruppe zurück
\item[] Returns: die Beschreibung der aktuell ausgewählten Gruppe

\item \texttt{void setGroupDescription(String description)}
\item[] Setzt die Beschreibung der Gruppe auf die vom Nutzer eingegebenen Beschreibung

\end{itemize}

\subsubsection{Class \texttt{SegmentController}}
Diese Klasse repräsentiert den Kontroller der das Tab mit den Segmenteinstellungen verwaltet

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Segmentcontroller(Repository<t> repository)}
\item[] Erstellt einen neuen SegmentController und dieser erhält das Repository mit allen verfügbaren Plugins
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void addStrategy(String strategyId}
\item[] Fügt die ausgewählte Strategy in die Liste der möglichen Strategien

\item \texttt{void removeStrategy(String segmentId)}
\item[] Entfernt sie ausgewählte Strategy aus der Liste der möglichen Startegien

\item \texttt{void selectCapitalDistribution(String segmentId, String distributionId)}
\item[] Setzt die Kapitalverteilungsfunktion des ausgewählten Segments aufs die ausgewählte Funktion

\item \texttt{int getCapitalDistribution(String segmentId)}
\item[] Gibt die Kapitalverteilung des ausgewählten Segments zurück
\item[] Returns: die Kapitalverteilungsfunktion des ausgewählten Segments

\item \texttt{getDistributionParameters(segmentId) : ???}
\item[] Gibt die Kapitalverteilungsparameter des ausgewählten Segments zurück
\item[] Returns: die Kapitalverteilungsparameter des ausgewählten Segments

\item \texttt{setDistributionParameters(String segmentId)}
\item[] Setzt die Verteilungsfunktionparameter auf die ausgewählten Werte


\end{itemize}


\subsubsection{Class \texttt{PopulationController}}
Diese Klasse repräsentiert den Kontroller der für das \enquote{Neue Population erstellen}-Fenster zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PopulationController(Repository<t> repository)}
\item[] Erstellt einen neuen PopulationController und dieser erhält das Repository mit allen verfügbaren Gruppen
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void addGroup(String groupId)}
\item[] Fügt eine über einen String klar definierbare Gruppe aus dem Repository zur Population hinzu

\item \texttt{void deleteGroup(String groupId)}
\item[] Löscht eine über einen String klar definierbare Gruppe aus der Population

\item \texttt{void setGroupSize(String groupId, int size)}
\item[] Setzt die Grösse der ausgewählten Gruppe auf die angegebene Anzahl an Agenten

\item \texttt{int getGroupSize(String groupId)}
\item[] Gibt die Grösse der ausgewählten Gruppe zurück
\item[] Returns: die Anzahl an Agenten der ausgewählten Gruppe

\item \texttt{String getPopulationName()}
\item[] Gibt den Namen der aktuellen Population zurück
\item[] Returns: der Name der aktuell ausgewählten Population

\item \texttt{void setPopulationName(String name)}
\item[] Setzt den Namen der Population auf den vom Nutzer eingegebenen Namen

\item \texttt{String getPopulationDescription()}
\item[] Gibt die Beschreibung der aktuellen Population zurück
\item[] Returns: die Beschreibung der aktuell ausgewählten Population

\item \texttt{void setPopulationDescription(String description)}
\item[] Setzt die Beschreibung der Population auf die vom Nutzer eingegebenen Beschreibung

\end{itemize}


\subsubsection{Class \texttt{NewGameController}}
Diese Klasse repräsentiert den Kontroller der für das \enquote{Neues Stufenspiel erstellen}-Fenster zuständig ist.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{NewGameController()}
\item[] Erstellt einen neuen NewGameController
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void setName()}
\item[] Stellt den Namen des Stufenspiels auf den im Fenster eingegebenen Namen


\item \texttt{Game getGame()}
\item[] Gibt das aktuell eingestellte Stufenspiel zurück
\item[] Returns: das aktuell eingestellte Stufenspiel

\item \texttt{void setDescription()}
\item[] Stellt die Beschreibung des Stufenspiels auf die im Fenster eingegebene Beschreibung

\item \texttt{void setPayments()}
\item[] Stellt die Werte der Matrix des Stufenspiels auf die im Fenster eingegebenen Werte

\item\texttt{void save()}
\item[] Speichert das aktuell eingegebene Stufenspiel ab

\item \texttt{void reset()}
\item[] Leert die Felder im Fenster für Name, Beschreibung und Auszahlungen

\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.plugin}}

\subsubsection{Class \texttt{PluginLoader}}

Diese Klasse stellt die Funktionalität zum Laden von Plugins mittels der Java \texttt{ServiceLoader}-API zur Verfügung

Methoden:

\begin{itemize}\itemsep -10pt
	\item \underline{\texttt{static <T> List<T> loadPlugins()}}
	\item[] Lädt alle verfügbaren Plugins des angegebenen Typs \texttt{T}
	\item[] \texttt{<T>} Plugintyp der geladen werden soll
	\item[]Returns: eine Liste der geladenen Plugins
\end{itemize}

\subsubsection{abstract Class \texttt{PluginControl extends javafx.scene.layout.Pane}}

Diese Klasse dient als Steuerelement für die Konfiguration eines Plugins. Sie stellt eine Funktionalität zum Abfragen der vom Benutzer eingegebenen Konfigurationsparameter zur Verfügung.

Methoden:

\begin{itemize}\itemsep -10pt
	\item \texttt{abstract List<double> getParameters()}
	\item[] Gibt eine Liste der eingegebene Parameter für die Pluginkonfiguration zurück
	\item[] Returns: eine Liste der eingegebenen \texttt{double}-Parameter
\end{itemize}

\subsubsection{Class \texttt{TextFieldPluginControl extends PluginControl}}

Diese Klasse ist eine Implementierung eines  \texttt{PluginControl}, bei der die Eingabe der Konfigurationsparameter über Textfelder erfolgt. Die Eingabe wird weiterhin bereits auf Korrektheit überprüft.

Konstruktoren:

\begin{itemize}\itemsep -10pt
	\item \texttt{TextFieldPluginControl(List<Parameter> params)}
	\item[] Erzeugt eine Instanz, die die übergebenen \texttt{Parameter} konfigurierbar macht.
	\item[] \texttt{params}: eine Liste der konfigurierbaren Parameter
\end{itemize}

Methoden:

\begin{itemize}\itemsep -10pt
	\item \texttt{void addParameter(Parameter param)}
	\item[] Fügt dem Steuerelement einen \texttt{Parameter} hinzu, der dann über das Steuerelement konfigurierbar ist
	\item[] \texttt{param}: Der Parameter, der zum Steuerelement hinzugefügt werden soll.
	\item \texttt{void addParameters(List<Parameter> params)}
	\item[] Fügt dem Steuerelement eine Liste von \texttt{Parameter}n hinzu, die dann über das Steuerelement konfigurierbar sind
	\item[] \texttt{params}: Die Parameter, die zum Steuerelement hinzugefügt werden sollen.
\end{itemize}

\subsubsection{Interface \texttt{PluginRenderer}}

Dieses Interface stellt die Funktionalität zum Erzeugen eines Konfigurations-Steuerelemet für Plugins in einer JavaFX Anwendung bereit.

Methoden:

\begin{itemize}\itemsep -10pt
	\item \texttt{PluginControl render()}
	\item[] Liefert eine \texttt{PluginControl}-Instanz zurück, die in ein JavaFX-Fenster eingefügt werden kann
\end{itemize}

\subsubsection{Class \texttt{GenericRenderer implements PluginRenderer}}

Diese Klasse implementiert das \texttt{PluginRenderer}-Interface und erzeugt für ein beliebiges Plugin ein generisches, Textfeld basiertes Konfigurations-Steuerelement (\texttt{TextFieldPluginControl}-Instanz).

Konstruktoren:

\begin{itemize}\itemsep -10pt
	\item \texttt{GenericRenderer(plugin: Plugin)}
	\item[] Erzeugt eine Instanz, die für das gegebene Plugin ein Konfigurations-Steuerelement erstellt
	\item[] \texttt{plugin}: Das Plugin welches der Renderer darstellen soll
	\item \texttt{GenericRednerer(params: List<Parameter>)}
	\item[] Erzeugt eine Instanz, die ein Steuerelement mit den gegebenen \texttt{Parameter} erzeugt.
	\item[] \texttt{params}: Eine Liste der konfigurierbaren Parameter eines Plugins
\end{itemize} 

\subsubsection{Class \texttt{Parameter implements Nameable}}

Diese Klasse definiert einen Konfigurationsparameter für Plugins. Sie bietet Funktionaliäten zum Festlegen des Wertebereichs und der Granularität des Konfigurationsparameter.

Konstruktoren:
\begin{itemize}\itemsep -10pt
	\item \texttt{Parameter()}
	\item[] Erzeugt eine neue Instanz mit unbeschränktem Wertebereich 
	\item \texttt{Parameter(double minVal)}
	\item[] Erzeugt eine neue Instanz mit nach unten beschränktem Wertebereich
	\item[] \texttt{minVal}: untere Schranke des Wertebereichs
	\item \texttt{Parameter(double maxVal)}
	\item[] Erzeugt eine neue Instanz mit nach oben beschränktem Wertebereich
	\item[] \texttt{maxVal}: obere Schranke des Wertebereichs
	\item \texttt{Parameter(double minVal, double maxVal)}
	\item[] Erzeugt eine neue Instanz mit nach unten und oben beschränktem Wertebereich
	\item[] \texttt{minVal}: untere Schranke des Wertebereichs
	\item[] \texttt{maxVal}: obere Schranke des Wertebereichs
	\item \texttt{Parameter(double minVal, double maxVal, double stepSize)}
	\item[] Erzeugt eine neue Instanz mit nach oben und unten beschränktem Wertebereich, sowie eingeschränkter Granularität
	\item[] \texttt{minVal}: untere Schranke des Wertebereichs
	\item[] \texttt{maxVal}: obere Schranke des Wertebereichs
	\item[] \texttt{stepSize}: Granularität des Parameters
	
\end{itemize}

Methoden:

\begin{itemize}\itemsep -10pt
	\item \texttt{double getMinValue()}
	\item[] Gibt die untere Schranke des gültigen Wertebereichs zurück
	\item[] Returns: die untere Schranke des gültigen Wertebereichs
	\item \texttt{double getMaxValue()}
	\item[] Gibt die obere Schranke des gültigen Wertebereichs zurück
	\item[]Returns: die obere Schranke des gültigen Wertebereichs
	\item \texttt{double getStepSize()}
	\item[] Gibt die Granularität des Wertebereichs zurück
	\item[]Returns: die Granularität des Wertebereichs
\end{itemize}

\subsubsection{Class \texttt{ParameterValidator}}

Diese Klasse bietet Funktionalitäten zum Validieren einer Parameterbelegung in Form von statischen Hilfsmethoden.

Methoden:

\begin{itemize} \itemsep -10pt
	\item \underline{\texttt{static boolean isValueValid(double val, Parameter param)}}
	\item[] Prüft, ob der gegeben Wert im Wertebereich des gegebenen Parameters liegt
	\item[] \texttt{val}: der Wert der überprüft werden soll
	\item[] \texttt{param}: der Parameter, dessen Wertebereich für die Überprüfung genutzt werden soll.
	\item[] Returns: \texttt{true}, wenn der Wert im Wertebereich des Parameters liegt \texttt{false} andernfalls
	\item \underline{\texttt{static double getClosestValid(double val, Parameter param)}}
	\item[] Gibt den Wert im Wertebereich des Parameters zurück, der am nächsten an dem gegebenen Wert liegt
	\item[] \texttt{val}: der Wert, der beim ermitteln betrachtet wird
	\item[] \texttt{param}: der Parameter, desssen Wertebereich betrachtet wird
	\item[] Returns: der Wert aus dem Wertebereich des Parameters, der dem gegebenen Wert am nächsten liegt
\end{itemize}

\subsubsection{abstract Class \texttt{Plugin<T> implements  Nameable}}

Diese Klasse stellt ein dynamisch ladbares Plugin da. Sie ist ein generischer Container für eine Klasse, die die eigentliche Pluginfunktionalität bereitstellt. Sie bietet Funktionalitäten zum erzeugen neuer parametrisierter Instanzen der Funktionalitätsklasse. Eine Liste der geforderten Konfigurationsparameter kann abgefragt werden.

Parameter:
\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} Der Typ der Klasse, welche die Pluginfunktionalität bereit stellt. 
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
	\item \texttt{PluginRenderer getRenderer()}
	\item[] Gibt eine \texttt{PluginRenderer}-Instanz zum Erzeugen eines Konfigurations-Steuerelements für das Plugin zurück
	\item[] Returns: eine Instanz eines \texttt{PluginRenderer}s
	\item \texttt{abstract List<Parameter> getParameters()}
	\item[] Gibt eine Liste der Konfigurationsparameter des Plugins zurück
	\item[] Returns: eine Liste der Konfigurationsparameter
	\item \texttt{abstract T getNewInstance(List<double> params)}
	\item[] Erzeugt eine neue Instanz der Klasse, die die Pluginfunktionalität bereitstellt und parametrisiert sie mit den übergebenen Werten der Konfigurationsparametern
	\item[] \texttt{params}: eine Liste mit den Werten der Konfigurationsparameter
	\item[] Returns: eine neue Instanz der Klasse, die die Pluginfunktionalität zur Verfügung stellt
\end{itemize}

\section{Glossar}
\textbf{Elementare Konfiguration:}
Eine Konfiguration, in der Multikonfiguration deaktiviert ist. Mit den \enquote{einer Konfiguration zugehörigen elementaren Konfigurationen} wird im Falle einer Multikonfiguration die Menge aller elementaren Konfigurationen bezeichnet, in denen der Multikonfigurationsparameter die festgelegte Wertemenge durchläuft. Im Falle einer elementare Konfiguration ist wieder die Konfiguration selbst gemeint.

\end{document}
