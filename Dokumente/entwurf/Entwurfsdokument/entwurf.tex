\documentclass[parskip=full,11pt]{scrartcl}

\usepackage[utf8]{inputenc}

%\title{Simulator für wiederholte Spiele}
%\author{Sebastian Feurer, Peter Koepernik, Luc Mercatoris,\\Christian Schorr, Pierre Toussing}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
%\usepackage[german]{babel}
\usepackage[english]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage{bbm}
\usepackage{amsmath} % for $\text{}$
\usepackage{amssymb}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float} % für Fließumgebungen; Platzierung H verschiebt nicht
\usepackage{multirow}
\restylefloat{figure}
\hypersetup{
	pdftitle={Entwurf},
	bookmarks=true,
}
\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\usepackage{pflichtenheft}

\usepackage[nonumberlist]{glossaries}

\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}

\begin{document}
\begin{titlepage}
	\centering
	\vspace*{5cm}
	\includegraphics[width = 0.7\linewidth]{images/Logos/loop.png}\par
	{\huge\bfseries Ein Simulator für wiederholte Spiele\par}
	%\vspace{1cm}
	{\Large Entwurfsdokument\par}
	\vspace{2cm}
	{\Large\itshape Sebastian Feurer, Peter Koepernik, Luc Mercatoris,\\Christian Schorr, Pierre Toussing\par}
	\vfill
	{\large \today\par}
\end{titlepage}

%\tableofcontents
%\pagebreak

\section{Introduction}
This document contains the design for \enquote{loop}, a simulation software for repeated games, as described in the \textit{Pflichtenheft}.

The object-oriented architecture of the project follows the model-view-controller (MVC) pattern, thus consists of three main packages: \texttt{view}, \texttt{controller} and \texttt{model}. The communication between view and model relies solely on the controller, hence the entirety of the model is decoupled from the view.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{images/package_diagram_overview.png}
	\caption{Sketch of the package structure. The view notifies the controller when the user interacts with the UI, who then uses the model to carry out tasks requested by the user. The controller observes the model to notice changes in the models computations and updates the view accordingly.}
	\label{package_overview}
\end{figure}

\subsection{The view}
Since the user interface (UI) of the program was designed using the UI-Builder \textit{NAMEEINFÜGEN}, the \texttt{view}-package contains mainly auto-generated classes provided by \textit{NAMEEINFÜGEN}.

The communication between view and model relies solely on the controller. Each window in the view has one controller assigned to it, that will be instantiated automatically when the window is opened and handles any input performed by the user.

\subsection{The controller}
The controller consists of a tree-like class hierarchy. At the top resides the \texttt{HeadController}, who is associated with the main window and thus instantiated when the program starts. The other controllers are arranged below and associated with the different popup windows such as the configuration- or the strategy creation window.

When the user requests a task that requires the involvement of the model (such as starting a simulation or saving a configuration file), the \texttt{HeadController} invokes the model, observes it for updates in its computation progress and updates the view accordingly.

When the user navigates to other windows the \texttt{HeadController} opens them and observes the corresponding controller so it can relay tasks to the model or close the window if needed.

\subsection{The model}
The model contains the \texttt{Simulator} class, which provides means for starting and stopping simulations to given configurations.

Since the execution of a simulation might take a considerable amount of time, depending on the configuration and the accessible hardware resources, simulations will be started asynchronously and an instance of the \texttt{SimulationResult} class will be returned instantly, which will be filled with the results of the single iterations as they finish. The \texttt{SimulationResult} offers a possibility to observe it in the sense that a method may be registered as functional interface which will be called whenever an iteration finishes.

The execution of a single iteration itself is encapsulated in the \texttt{SimulationEngine} class. It receives an instance of the \texttt{Configuation} class and returns the result of the simulation as an instance of the \texttt{IterationResult}. The simulation process is implemented as a template method and the configuration is queried whenever a varaible event such as the strategy adjustion or the agent pairing occurs.

The model contains interfaces representing those variable events and provides implementations for the mechanisms and algorithms described in the \textit{Pflichtenheft}. The user may implement those interfaces himself and integrate them in the program using the plug-in system which is also part of the model.

\section{Specification changes}

\subsection{Populations}
The concept of groups and segments has been revised. The entirety of groups and segments with all their settings (except for the multiconfiguration) is now called a \enquote{population}. The creation of groups and segments no longer takes place in the configuration window. Instead, populations and groups can be created, stored and loaded individually (such as strategies or games) (see \cref{?}).

\textbf{Group Creation:}
The name and the description of a group can be entered in corresponding text fields at the top of the creation window. The amount of segments, their sizes and their strategy- and capital distributions can be configurated via a Tab-Control element (as originally in the configuration window). Furthermore, a group can be declared as \enquote{coherent} by activating a correspondig checkbox. Per default, this checkbox is activated. When it is deactivated, the agents of this group no longer consider each other as agents of the same group. This replaces the concept of \enquote{groupless agents}. Once the group configuration is completed, the group can be exported as a file. Such a file can also be imported.

\textbf{Population Creation:}
The name and the description of a population can be entered in corresponding text fields at the top of the creation window. Below, \(1\) to \(16\) groups can be added, each with specified size (see \cref{?}). Once the population configuration is completed, the population can be exported as a file. Such a file can also be imported.

The configuration window is no longer divided in three parts. The \enquote{group settings} have been replaced by a single dropdown menu titled \enquote{population} and the \enquote{basic} and \enquote{advanced} settings have been fused. Below the dropdown menu, a section showing the composition of the selected population can expanded. This section looks the same as the former \enquote{group settings} and can be used to activate the multiconfiguration for groups or segments, though the population itself cannot be changed.

\subsection{Strategies}
The list of all variables that can appear as literals in a strategy was extended by the following:
\begin{itemize}
\item In previous games (of the current adaption step), B has cooperated always/never/last time/at least in games with agents that are in the same group as A.
\item In previous games (of the current adaption step), B has cooperated always/never/last time/at least once in games with agents that have a similar capital as A.
\end{itemize}

\subsection{Plugin system}

A plugin system which allows to dynamically load new functionality at runtime has been added. This grants the user the flexibility to implement and integrate own versions of the following algorithms and mechanisms:
\begin{itemize} \itemsep -10pt
	\item the equilibrium criterion
	\item the success quantifier
	\item the strategy adjuster
	\item the pair builder
	\item the discrete distribution
\end{itemize}

Furthermore it is possible to make the plugins user configurable in the configuration window. Therefor plugins provide a renderer which creates user control objects that can be dinamically embedded into the UI within the configuration window. The plugins are loaded automatically at the start of the program.

\section{Pakete und Klassen}

\subsection{Paket \texttt{edu.kit.loop}}

\subsubsection{Class \texttt{Main}}
Extends: \texttt{javafx.application.Application}

This class contains the main method of the program and initialises the main window.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{static void main(String[] args))}
\item[] The entry point of the application. Loads the UI and starts the window.
\item[] \texttt{args}: the commandline arguments. (unused)
\end{itemize}

\subsection{Package \texttt{edu.kit.loop.model}}
The model contains the \texttt{Simulator} interface, which provides means of starting und stopping simulations to given configurations. When a simulation is started, an instance of the class \texttt{SimulationResult} is returned instantly, which collects the results of the single iterations as they finish. The execution of the iterations is carried out by instances of the \texttt{SimulationEngine} class.

The model contains a central repository which gives static access to all available populations, groups, strategies, games, pair builders, success quantifiers, strategy adjusters, equilibrium criteria and capital distributions. The access key for the stored instances is their name, wherefore all corresponding classes and interfaces implement the \texttt{Nameable} interface. Populations, groups, strategies, games and configurations can also be exported and imported as files, which is why all of those must be \texttt{Serializable}.

The configuration of a simulation, as specified by the user in the configuration window, is represented by the \texttt{UserConfiguration} class. It directly stores the users input, where numerical inputs are represented by \texttt{integer}s or \texttt{double}s and algorithms, populations, strategies etc. are represented as \texttt{String}s containing the corresponding names. When a simulation to a given \texttt{UserConfiguration} is started, an instance of the \texttt{Configuration} class is generated for each associated elementary configuration. An instance of the \texttt{Configuration} class contains only the information needed to execute a single iteration and holds references to concrete instances of all involved classes (such as the pair builder, the success quantifier and the strategies).

Lastly, the model contains the plugin system which can be used to integrate own implementations of the pair builder, the strategy adjuster, the success quantifier, the equilibrium criterion or the discrete distribution.

\subsubsection{Class \texttt{UserConfiguration}}
Implements: \texttt{java.io.Serializable}

This class represents a user-created configuration. It provides getter methods for all parameters as well as static access to a default configuration.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{UserConfiguration(String gameName, int agentCount, int roundCount, int iterationCount, List<String> availableStrategyNames, boolean mixedAllowed, String populationName, String pairBuilderName, List<double> pairBuilderParameters, String successQuantifierName, List<double> successQuantifierParameters, String strategyAdjusterName, List<double> strategyAdjusterParameters, String\\ equilibriumCriterionName, List<double> equilibriumCriterionParameters, int maxAdapts, boolean isMulticonfiguration, String variableParameterName, double startValue, double endValue, double stepSize)}
\item[] Creates a new \texttt{UserConfiguration} with the given parameters
\item[] \texttt{gameName}: the name of the game
\item[] \texttt{agentCount}: the amount of agents
\item[] \texttt{roundCount}: the amount of rounds per adaptionstep
\item[] \texttt{iterationCount}: the amount of iterations
\item[] \texttt{availableStrategyNames}: a list with the names of all allowed strategies
\item[] \texttt{mixedAllowed}: \texttt{true}, if mixed strategies are allowed, \texttt{false} otherwise.
\item[] \texttt{populationName}: the name of the population
\item[] \texttt{pairBuilderNames}: the name of the pair builder
\item[] \texttt{pairBuilderParameters}: a list with the values of the parameters of the pair builder
\item[] \texttt{successQuantifierNames}: the name of the success quantifier
\item[] \texttt{successQuantifierParameters}: a list with the values of the parameters of the success quantifier
\item[] \texttt{strategyAdjusterName}: the name of the strategy adjuster
\item[] \texttt{strategyAdjusterParameters}: a list with the values of the parameters of the strategy adjuster
\item[] \texttt{equilibriumCriterionName}: the name of the equilibrium criterion
\item[] \texttt{equilibriumCriterionParameters}: a list with the values of the parameters of the equilibrium criterion
\item[] \texttt{maxAdapts}: the maximum amount of simulated adaption steps per iteration
\item[] \texttt{isMulticonfiguration}: \texttt{true}, if this is a multiconfiguration, \texttt{false} otherwise
\item[] \texttt{variableParameterName}: the name of the multiconfiguration parameter, if this is a multiconfiguration, \texttt{""} otherwise
\item[] \texttt{startValue}: the starting value of the multiconfiguration parameter, if this is a multiconfiguration, \(0\) otherwise
\item[] \texttt{endValue}: the end value of the multiconfiguration parameter, if this is a multiconfiguration, \(0\) otherwise
\item[] \texttt{stepSize}: the step size of the multiconfiguration parameter, if this is a multiconfiguration, \(0\) otherwise
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{static UserConfiguration getDefaultConfiguration()}
	\item[] Returns a default version of this configuration. The default configuration will be the active configuration at the start of the program.
	\item[] Returns: a default configuration

	\item \texttt{String getGameName()}
	\item[] Returns the name of the game of this configuration
	\item[] Returns: the name of the game of this configuration

	\item \texttt{int getAgentCount()}
	\item[] Returns the amount of agents in this configuration
	\item[] Returns: the amount of agents in this configuration

	\item \texttt{int getRoundCount()}
	\item[] Returns the amount of rounds per adaption step in this configuration
	\item[] Returns: the amount of rounds per adaption step in this configuration

	\item \texttt{int getIterationCount()}
	\item[] Returns the amount of iterations in this configuration
	\item[] Returns: the amount of iterations in this configuration

	\item \texttt{List<String> getAvailableStrategyNames()}
	\item[] Returns a list with names of all available strategies in this configuration
	\item[] Returns: a list with names of all available strategies in this configuration

	\item \texttt{boolean getMixedAllowed()}
	\item[] Returns, whether mixed strategies are allowed in this configuration
	\item[] Returns: \texttt{true}, if mixed strategies are allowed in this configuration; \texttt{false} otherwise

	\item \texttt{String getPopulationName()}
	\item[] Returns the name of the \texttt{Population} of this configuration
	\item[] Returns: a list with the names of all populations in this configuration

	\item \texttt{String getPairBuilderName()}
	\item[] Returns the name of the \texttt{PairBuilder} of this configuration
	\item[] Returns: the name of the \texttt{PairBuilder} of this configuration

	\item \texttt{List<double> getPairBuilderParameters()}
	\item[] Returns a list with the values of the parameters of the \texttt{PairBuilder} of this configuration
	\item[] Returns: a list with the values of the parameters of the \texttt{PairBuilder} of this configuration

	\item \texttt{String getSuccessQuantifierName()}
	\item[] Returns the name of the \texttt{SuccessQuantifier} of this configuration
	\item[] Returns: the name of the \texttt{SuccessQuantifier} of this configuration

	\item \texttt{List<double> getSuccessQuantifierParameters()}
	\item[] Returns a list with the values of the parameters of the \texttt{SuccessQuantifier} of this configuration
	\item[] Returns: a list with the values of the parameters of the \texttt{SuccessQuantifier} of this configuration

	\item \texttt{String getStrategyAdjusterName()}
	\item[] Returns the name of the \texttt{PairBuilder} of this configuration.
	\item[] Returns: the name of the \texttt{PairBuilder} of this configuration

	\item \texttt{List<double> getStrategyAdjusterParameters()}
	\item[] Returns a list with the values of the parameters of the \texttt{StrategyAdjuster} of this configuration
	\item[] Returns: a list with the values of the parameters of the \texttt{StrategyAdjuster} of this configuration


	\item \texttt{String getEquilibriumCriterionName()}
	\item[] Returns the name of the \texttt{EquilibriumCriterion} of this configuration.
	\item[] Returns: the name of the \texttt{EquilibriumCriterion} of this configuration.

	\item \texttt{List<double> getEquilibriumParameters()}
	\item[] Returns a list with the values of the parameters of the \texttt{EquilibriumCriterion} of this configuration
	\item[] Returns: a list with the values of the parameters of the \texttt{EquilibriumCriterion} of this configuration

	\item \texttt{int getMaxAdapts()}
	\item[] Returns the maximum amount of simulated adaption steps per iteration in this configuration
	\item[] Returns: the maximum amount of simulated adaption steps per iteration in this configuration

	\item \texttt{boolean isMulticonfiguration()}
	\item[] Returns whether this is a multiconfiguration.
	\item[] Returns: \texttt{true}, if this is a multiconfiguration, \texttt{false} otherwise

	\item \texttt{String getVariableParameterName()}
	\item[] Returns the name of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \texttt{""} otherwise.
	\item[] Returns: the name of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \texttt{""} otherwise

	\item \texttt{double getStartValue()}
	\item[] Returns the starting value of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise.
	\item[] Returns: the starting value of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise

	\item \texttt{double getEndValue()}
	\item[] Returns the end value of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise.
	\item[] Returns: the end value of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise

	\item \texttt{double getStepSize()}
	\item[] Returns the step size of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise.
	\item[] Returns: the step size of the multiconfiguration parameter of this configuration, if this is a multiconfiguration; \(0\) otherwise



\end{itemize}


\subsubsection{Interface \texttt{Nameable}}

Implementations of this interface have a name and a description, which can be queried as \texttt {String}s.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{String getName()}
\item[] Returns the name of this object.
\item[] Returns: the name of this object

\item \texttt{String getDescription()}
\item[] Returns the description of this object.
\item[] Returns: the description of this object
\end{itemize}

\subsubsection{Class \texttt{Population}}
Implements: \texttt{Nameable}, \texttt{java.io.Serializable}

This class represents a population. It offers getter methods for size and group composition.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{Population(String name, String description, List<Group> groups, List<Integer> groupSizes)}
\item[] Creates a new population with name, description and group composition as given.
\item[] \texttt{name}: the name of this population
\item[] \texttt{description}: the description of this population
\item[] \texttt{groups}: the groups this population is composed of
\item[] \texttt{groupSizes}: the sizes of the groups, in the same order as the groups themselves
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getSize()}
\item[] Returns the size of this population.
\item[] Returns: the size of this population

\item \texttt{List<Group> getGroups()}
\item[] Returns the groups this population is composed of.
\item[] Returns: the groups this population is composed of

\item \texttt{int getGroupSize(Group group)}
\item[] Returns the size of the given group if it is part of this population, \(0\) otherwise.
\item[] \texttt{group}: the group whose size shall be returned
\item[] Returns: the size of the given group if it is part of this population, \(0\) otherwise

\item \texttt{int getGroupCount()}
\item[] Returns the amount of groups in this population
\item[] Returns: the amount of groups in this population
\end{itemize}

\subsubsection{Class \texttt{Group}}
Implements: \texttt{Nameable}, \texttt{java.io.Serializable}

This class represents a group. It provides getter methods for its segmental composition and cohesion.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{Group(String name, String description, List<Segment> segments, List<Double> segmentSizes, boolean isCohesive)}
\item[] Creates a new group with name, description and segment composition as given
\item[] \texttt{name}: the name of this group
\item[] \texttt{description}: the description of this group
\item[] \texttt{segments}: the segments this group is composed of
\item[] \texttt{segmentSizes}: the relative sizes of the segments in the same order as the segments themselves
\item[] \texttt{isCohesive}: indicates whether this group is cohesive
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Segment> getSegments()}
\item[] Returns a list of the segments this group is composed of.
\item[] Returns: a list of the segments this group is composed of

\item \texttt{double getSegmentSize(Segment segment)}
\item[] Returns the relative size of the given segment if it is part of this group, \(0\) otherwise.
\item[] \texttt{segment}: the segment whose relative size shall be returned
\item[] Returns: the relative size of the given Segment if it is part of this group, \(0\) otherwise

\item \texttt{int getSegmentCount()}
\item[] Returns the amount of segments in this group.
\item[] Returns: the amount of segments in this group

\item \texttt{boolean isCohesive()}
\item[] Returns whether this group is cohesive.
\item[] Returns: \texttt{true} if this group is cohesive, \texttt{false} otherwise
\end{itemize}

\subsubsection{Class \texttt{Segment}}
Implements: \texttt{java.io.Serializable}

This class represents a segment. It provides getter methods for (the names of) its capital- and strategy distributions.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{Segment(String capitalDistributionName, Collection<String> strategyNames)}
\item[] Creates a new segment with the given capital- and strategy distribution
\item[] \texttt{capitalDistributionName}: the name of the capital distribution of this segment
\item[] \texttt{strategyNames}: the names of the strategies in the strategy distribution of this segment
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{String getCapitalDistributionName()}
\item[] Returns the name of the capital distribution of this segment.
\item[] Returns: the name of the capital distribution of this segment

\item \texttt{List<String> getStrategyNames()}
\item[] Returns the names of the strategies in the strategy distribution of this segment.
\item[] Returns: the names of the strategies in the strategy distribution of this segment
\end{itemize}


\subsection{Paket \texttt{edu.kit.loop.model.simulator}}
This package contains the \texttt{Simulator}, which is the models interface for starting and stopping simulations.

\subsubsection{Class \texttt{SimulationResult}}
A \texttt{SimulationResult} object contains information about a started simulation, such as its configuration, execution status, \texttt{id} and, if available, the results of the iterations. It is generated by a \texttt{Simulator} when a simulation is started.

The class does not distinguish between multiconfigurations and non-multiconfigurations, so it generally assumes that several elementary configurations underlie.

Constructors:
\begin{itemize} \itemsep -10pt
	\item \texttt{SimulationResult(UserConfiguration config, int id)}
	\item[] Creates a new simulation result to a simulation with given configuration and \texttt{id}.
	\item[] \texttt{config}: the configuration of the simulation
	\item[] \texttt{id}: the \texttt{id} of the simulation
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{protected void addIterationResult(IterationResult result, int i)}
	\item[] adds an \texttt{IterationResult} to the \texttt{i}-th elementary configuration and triggers all registered actions.
	\item[] \texttt{result}: the iteration result that shall be added
	\item[] \texttt{i}: the elementary configuration to which the given result shall be added

	\item \texttt{protected void addSimulationEngineException(SimulationEngineException ex)}
	\item[] Adds a \texttt{SimulationEngineException} to this Simulaton and triggers all registered exception handlers.
	\item[] \texttt{ex}: the exception that shall be added

	\item \texttt{void registerIterationFinished(BiConsumer<SimulationResult,IterationResult> action)}
	\item[] Registers an action that will be executed every time an iteration of this simulation is finished. The \texttt{IterationResult} of the iteration as well as this instance will be passed as an argument to the action.
	\item[] \texttt{action}: the action that shall be executed whenever an iteration finishes

	\item \texttt{void registerExceptionHandler(BiConsumer<SimulationResult,SimulationEngineException> handler)}
	\item[] Registers a handler that will be executed every time an exception corresponding to this simulation occurs.
	\item[] \texttt{handler}: the handler that shall be executed whenever an exception occurs

	\item \texttt{List<IterationResult> getIterationResults(int i)}
	\item[] Returns a list of all yet available results of iterations with the \texttt{i}-th elementary configuration.
	\item[] \texttt{i}: the elementary configuration whose finished iterations shall be returned
	\item[] Returns: a list of all yet available results of iterations with the \texttt{i}-th elementary configuration

	\item \texttt{UserConfiguration getUserConfiguration()}
	\item[] Returns the \texttt{UserConfiguration} of this simulation.
	\item[] Returns: the \texttt{UserConfiguration} of this simulation

	\item \texttt{int getConfigurationCount()}
	\item[] Returns the amount of elementary configurations of this simulation (\(1\) if this is not a multiconfiguration).
	\item[] Returns: the amount of elementary configurations of this simulation

	\item \texttt{int getId()}
	\item[] Returns the \texttt{id} of this simulation.
	\item[] Returns: the \texttt{id} of this simulation
\end{itemize}

\subsubsection{Interface \texttt{Simulator}}
An implementation of this interface provides means of starting and stopping simulations to given (user) configurations. A \texttt{SimulationResult} to a started simulation will be returned instantly.

Each simulation gets a unique \texttt{id} assigned to it upon start.

Methods:
\begin{itemize} \itemsep -10pt
	\item \texttt{SimulationResult startSimulation(UserConfiguration config)}
	\item[] Starts a new simulation with the given configuration and returns a handle to a \texttt{SimulationResult} object for the started simulation.
	\item[]\texttt{config}: the configuration for which a simulation shall be started
	\item[] Returns: a handle to a \texttt{SimulationResult} object for the started simulation
	\item[] Throws: \texttt{ConfigurationException} when the provided configuration is faulty

	\item \texttt{SimulationResult startSimulation(UserConfiguration config, Consumer<SimulationResult> action)}
	\item[] Starts a new simulation with the given configuration and returns a handle to a \texttt{SimulationResult} object for the started simulation. Executes the given action with the \texttt{SimulationResult} object passed as parameter when the started simulation is finished.
	\item[] \texttt{config}: the configuration a new simulation shall be started with
	\item[] \texttt{action}: the action that shall be executed when the simulation is finished
	\item[] Returns: a handle to a \texttt{SimulationResult} object for the started simulation
	\item[] Throws: \texttt{ConfigurationException} when the provided configuration is faulty

	\item \texttt{boolean stopSimulation(SimulationResult sim)}
	\item[] Stop the execution of the simulation corresponding to the given simulation result if it is currently running.
	\item[] \texttt{sim}: the \texttt{SimulationResult} object of the simulation whose execution shall be stopped
	\item[] Returns: \texttt{true}, if the execution of the simulation was successfully stopped, \texttt{false} otherwise

	\item \texttt{boolean stopSimulation(int id)}
	\item[] If a simulation with the given \texttt{id} is currently running, stop its execution.
	\item[] \texttt{id}: the \texttt{id} of the simulation that shall be stopped
	\item[] Returns: \texttt{true}, if the execution of the simulation was successfully stopped, \texttt{false} otherwise

	\item \texttt{void stopAllSimulations()}
	\item[] Stops the execution of all running simulations.

	\item \texttt{SimulationResult getSimulation(int id)}
	\item[] Returns the \texttt{SimulationResult} object of the simulation with the given \texttt{id}, if existent; \texttt{null} otherwise.
	\item[] \texttt{id}: the \texttt{id} of the simulation, whose \texttt{SimulationResult} object shall be returned
	\item[] Returns: the \texttt{SimulationResult}-object of the simulation with the given \texttt{id}, if existent; \texttt{null} otherwise
\end{itemize}

\subsubsection{Class \texttt{ThreadPoolSimulator}}
Implements: \texttt{Simulator}

An implementation of the \texttt{Simulator} interface. Executes the iterations in parallel using a thread pool.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{ThreadPoolSimulator()}
\item[] Creates a new \texttt{ThreadPoolSimulator}.

\item \texttt{ThreadPoolSimulator(int maxThreads)}
\item[] Creates a new \texttt{ThreadPoolSimulator} with the given maximum amount of running threads.
\item[] \texttt{maxThreads}: the maximum amount of running threads in the thread pool
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getRunningIterationCount()}
\item[] Returns the amount of currently executed iterations.
\item[] Returns: the amount of currently executed iterations

\item \texttt{int getQueuedIterationCount()}
\item[] Returns the amount of iterations currently waiting for execution.
\item[] Returns: the amount of iterations currently waiting for execution
\end{itemize}

\subsubsection{Class \texttt{ConfigurationCreator}}
This class takes a \texttt{UserConfiguration} and generates all associated elementary configurations. These are returned as \texttt{Configuration}s. It also provides functionality to create a deep copy of a \texttt{Configuration}.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{static List<Configuration> generateConfigurations(UserConfiguration config)}
\item[] Generates all associated elementary configurations to the given \texttt{UserConfiguration} and returns them as \texttt{Configuration}s.
\item[] \texttt{config}: the \texttt{UserConfiguration} whose associated elementary configurations shall be generated
\item[] Returns: all associated elementary configurations of the given \texttt{UserConfiguration} as \texttt{Configuration}s

\item \texttt{static Configuration getCopy(Configuration config)}
\item[] Provides a deep copy of the given configuration.
\item[] \texttt{conig}: the configuration to copy
\item[] Returns: the newly created deep copy of the given configuration
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.Simulator.exception}}

\subsubsection{Abstract Class \texttt{ConfigurationException }}
Extends: java.lang.Exception

The \texttt{ConfigurationException} is a type of exception that occurs whenever the simulator gets passed a faulty \texttt{UserConfiguration}. It gets thrown by the \texttt{startSimulation}-method of the \texttt{Simulator}interface.

\subsubsection{Class \texttt{InvalidParameterException}}
Extends: \texttt{ConfigurationException}

A \texttt{ConfigurationException} that is thrown when one of the numerical parameters in a \texttt{UserConfiguration} given to a \texttt{Simulator} has an invalid value assigned to it.

Constructors:
\begin{itemize} \itemsep -10pt
	\item \texttt{InvalidParameterException(double value, String name)}
	\item[] Creates a new \texttt{InvalidParameterException}.
	\item[] \texttt{value}: the value of the faulty parameter
	\item[] \texttt{name}: the name of the faulty parameter configuration
\end{itemize}

Methods
\begin{itemize}\itemsep -10pt
	\item \texttt{double getParameterValue()}
	\item[] This method returns the value of the faulty parameter.
	\item[] Returns: the value of the faulty paramter
	\item \texttt{String getParameterName()}
	\item[] This method returns the name of the faulty parameter.
	\item[] Returns: the name of the faulty parameter
\end{itemize}

\subsubsection{Abstract Class \texttt{PluginException}}
Extends: \texttt{ConfigurationException}

A \texttt{ConfigurationException} that is thrown when an error associated with one of the plugins referenced by a given \texttt{UserConfiguration} occured.

Methods:
\begin{itemize} \itemsep -10pt
	\item \texttt{String getPluginName()}
	\item[] This method returns the name of the plugin that caused the error
	\item[] Returns: the name of the plugin that caused the error
\end{itemize}

\subsubsection{Class \texttt{PluginNotFoundException}}
Extends: \texttt{PluginException}

This \texttt{PluginException} is thrown when a plugin referenced by a given \texttt{UserConfiguration} could not be found (i.e. when the name given by the configuration is not known to the repository).

Constructors:
\begin{itemize} \itemsep -10pt
	\item \texttt{PluginNotFoundException(String name)}
	\item[] Creates a new \texttt{PluginNotFoundException}.
	\item[] \texttt{name}: the name of the plugin that was not found
\end{itemize}

\subsubsection{Class \texttt{PluginConfigurationException}}
Extends: \texttt{PluginException}

This \texttt{PluginException} is thrown when one of the plugin configuration parameters provided by a given \texttt{UserConfiguration} is faulty.

Constructors:
\begin{itemize}\itemsep -10pt
	\item \texttt{PluginConfigurationException(String name, List<Double> parameters)}
	\item[] Creates a new \texttt{PluginConfigurationException}.
	\item[] \texttt{name}: the name of the plugin
	\item[] \texttt{parameters}: a list of all faulty configuration parameters
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{List<Double> getParameter()}
	\item[] This method returns a list of all faulty parameters
	\item[] Returns: a list of all faulty parameters
\end{itemize}

\subsubsection{Class \texttt{SimulationEngineException}}
Extends: \texttt{java.lang.Exception}

The \texttt{SimulationEngineException} is a type of exception that is thrown whenever an error within the \texttt{executeIteration} method of a \texttt{SimulationEngine} has occured. The error gets caught by the simulator which then creates an instance of this class and writes it to the corresponding \texttt{SimulationResult} object.

\subsection{Paket \texttt{edu.kit.loop.model.simulationengine}}

This package contains the \texttt{SimulationEngine}-class, which can be used to perform a single repetition on a particular elementary configuration, as well as core classes such as the \texttt{Agent}, the \texttt{game} or the \texttt{Strategy}.

\subsubsection{Class \texttt{AgentInitialiser}}
An \texttt{AgentInitialiser} can be used to create the agents of a given segment and initialise them with capital, strategies, and group affiliation.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{AgentInitialiser()}
\item[] Creates a new \texttt{AgentInitialiser}.
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> initialiseAgents(EngineSegment segment)}
\item[] Creates and returns all agents of the given segment and initialises them with capital, strategy and group affiliation.
\item[] Returns: the initialised agents
\end{itemize}

\subsubsection{Interface \texttt{SimulationHistory}}
An implementation of the \texttt{SimulationHistory} interface stores the results of all previous rounds of an adaptation step for each agent.

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{void addResult(GameResult result)}
	\item[] Adds the result of (the game of) a round to the history.
	\item[] \texttt{result}: the \texttt{GameResult} that shall be added
	\item \texttt{List<GameResult> getAllResults()}
	\item[] Returns a list of the \texttt{GameResult}s of all agents and all rounds of the current adaption step.
	\item[]Returns: a list of the \texttt{GameResult}s of all agents and all rounds of the current adaption step
	\item \texttt{List<GameResult> getResultsByAgent(agent: Agent)}
	\item[] Returns a list of all \texttt{GameResult}s of the given agent.
	\item[] \texttt{agent}: the agent whose results shall be returned
	\item[]Returns: a list of all \texttt{GameResult}s of the given agent
	\item \texttt{List<GameResult> getLatestResults()}
	\item[] Returns the most recent \texttt{GameResult} of every agent.
	\item[]Returns: the most recent \texttt{GameResult} of every agent
	\item \texttt{GameResult getLatestResultByAgent(agent: Agent)}
	\item[] Returns the most recent \texttt{GameResult} of the given agent.
	\item[] \texttt{agent}: the agent whose latest result shall be returned
	\item[]Returns: the most recent \texttt{GameResult} of the given agent
	\item \texttt{List<GameResult> getAllWhere(condition: Predicate<GameResult>)}
	\item[] Filters all \texttt{GameResult} with the given condition and returns them.
	\item[]\texttt{condition}: the filter condition as \texttt{Predicate<GameResult>}
	\item[]Returns: Die filtered \texttt{GameResult}s
	\item \texttt{GameResult getLatestWhere(condition: Predicate<GameResult>)}
	\item[] Returns the latest \texttt{GameResult} that meets the given condition
	\item[]\texttt{condition}: the filter condition as \texttt{Predicate<GameResult>}
	\item[]Returns: the latest \texttt{GameResult} that meets the given condition
\end{itemize}

\subsubsection{Class \texttt{SimulationHistoryTable}}
Implements: \texttt{SimulationHistory}

This  class implements the \texttt{SimulationHistory}-interface.

\subsubsection{Class \texttt{Configuration}}
This class represents the elementary configuration of a single iteration and contains all the information about how to start one:
\begin{itemize}\itemsep -10pt
\item Game
\item Number of agents
\item Rounds per adaptation step
\item Whether mixed strategies are allowed
\item Group-/Segment formations
\item Capital- and Strategy classification of the segments
\item Agents pairing
\item Succes quantification
\item Adaption mechanism
\item Equilibrium criterion
\item Maximum number of adaptation steps
\end{itemize}

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{Configuration(Game game, int roundCount, boolean mixedStrategies, List<EngineSegment> segments, PairBuilder pairBuilder, SuccessQuantifier successQuantifier, SrategyAdjuster strategyAdjuster, EquilibriumCriterion equilibriumCriterion, int maxAdapts)}
\item[] Creates a new \texttt{Configuration} with the given parameters.
\item[] \texttt{game}: the game of this configuration
\item[] \texttt{roundCount}: the amount of rounds per adaption step in this configuration
\item[] \texttt{mixedStrategies}: \texttt{true}, if mixed strategies are allowed in this configuration, \texttt{false} otherwise
\item[] \texttt{segments}: all segments of this configuration
\item[] \texttt{pairBuilder}: the \texttt{PairBuilder} of this configuration
\item[] \texttt{successQuantifier}: the \texttt{SuccessQuantifier} of this configuration
\item[] \texttt{strategyAdjuster}: the \texttt{StrategyAdjuster} of this configuration
\item[] \texttt{equilibriumCriterion}: the \texttt{EquilibriumCriterion} of this configuration
\item[] \texttt{maxAdapts}: the maximum amount of simulated adaption steps per iteration in this configuration
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{Game getGame()}
\item[] Returns the game of this configuration
\item[] Returns: the game of this configuration

\item \texttt{int getAgentCount()}
\item[] Returns the amount of agents in this configuration
\item[] Returns: the amount of agents in this configuration

\item \texttt{int getRoundCount()}
\item[] Returns the amount of rounds per adaption step in this configuration
\item[] Returns: the amount of rounds per adaption step in this configuration

\item \texttt{boolean allowsMixedStrategies()}
\item[] Returns, whether mixed strategies are allowed in this configuration.
\item[] Returns: \texttt{true}, if mixed strategies are allowed in this configuration, \texttt{false} otherwise

\item \texttt{List<EngineSegment> getSegments()}
\item[] Returns all segments belonging to this configuration
\item[] Returns: all segments belonging to this configuration as \texttt{List<EngineSegment>}

\item \texttt{PairBuilder getPairBuilder()}
\item[] Returns the \texttt{pairBuilder} of this configuration.
\item[] Returns: the \texttt{pairBuilder} of this configuration

\item \texttt{SuccessQuantifier getSuccessQuantifier()}
\item[] Returns the \texttt{SuccessQuantifier} of this configuration.
\item[] Returns: the \texttt{SuccessQuantifier} of this configuration

\item \texttt{StrategyAdjuster getStrategyAdjuster()}
\item[] Returns the \texttt{StrategyAdjuster} of this configuration.
\item[] Returns: the \texttt{StrategyAdjuster} of this configuration

\item \texttt{EquilibriumCriterion getEquilibriumCriterion()}
\item[] Returns the \texttt{EquilibriumCriterion} of this configuration.
\item[] Returns: the \texttt{EquilibriumCriterion} of this configuration

\item \texttt{int getMaxAdapts()}
\item[] Returns the maximum amount of simulated adaption steps per iteration in this configuration
\item[] Returns: the maximum amount of simulated adaption steps per iteration in this configuration
\end{itemize}

\subsubsection{Class \texttt{SimulationEngine}}
This class provides a method to perform a single iteration of a given elementary configuration. The result is returned in the form of an \texttt{IterationResult} object.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{IterationResult executeIteration(Configuration configuration)}
\item[] Executes an iteration with the given elementary configuration and returns an \texttt{IterationResult}-object upon finishing.
\item[] \texttt{configuration}: the elementary configuration of the iteration that shall be executed
\item[] Returns: the result of the iteration as \texttt{IterationResult}
\end{itemize}

\subsubsection{Class \texttt{IterationResult}}
In an object of this class, the results of a finished iteration can be stored and retrieved:
\begin{itemize}\itemsep -10pt
\item The agents, sorted by rank as \texttt{List<Agent>}
\item The course of the last adaptation step as \texttt{SimulationHistory}
\item Whether an equilibrium has occurred
\item The efficiency of the final state
\item The number of adaptation steps performed
\end{itemize}

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{IterationResult(List<Agent> agents, SimulationHistory history, boolean equilibriumReached, double efficiency, int adapts)}
\item[] Creates a new \texttt{IterationResult}-object with the given iteration results.
\item[] \texttt{agents}: the agents, ordered by final rank
\item[] \texttt{history}: the \texttt{SimulationHistory} of the last adaption step
\item[] \texttt{equilibriumReached}: \texttt{true} if an equilibrium was reached, \texttt{false} otherwise
\item[] \texttt{efficiency}: the efficiency of the final state
\item[] \texttt{adapts}: the amount of simulated adaption steps
\end{itemize}

Methods
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> getAgents()}
\item[] Returns a list of all agents, ordered by final rank
\item[] Returns: a list of all agents, ordered by final rank

\item \texttt{SimulationHistory getHistory()}
\item[] Returns the \texttt{SimulationHistory} of the last adaption step
\item[] Returns: the \texttt{SimulationHistory} of the last adaption step

\item \texttt{boolean equilibriumReached()}
\item[] Returns whether an equilibrium was reached
\item[] Returns: \texttt{true} if an equilibrium was reached, \texttt{false} otherwise

\item \texttt{double getEfficiency()}
\item[] Returns the efficiency of the final state
\item[] Returns: the efficiency of the final state

\item \texttt{int getAdapts()}
\item[] Returns the amount of simulated adaption steps
\item[] Returns: the amount of simulated adaption steps
\end{itemize}

\subsubsection{Class \texttt{Agent}}
This class represents a single agent in a simulation run. It contains information about the agent, such as its group affiliation, its current and initial capital, or its current strategy.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{Agent(int initialCapital, Strategy initialStrategy, int groupId)}
\item[] Creates a new \texttt{Agent} with given initial capital, given strategy and given group affiliation
\item[] \texttt{initialCaptial}: the initial captital of the agent
\item[] \texttt{initialStrategy}: the initial \texttt{Strategy} of the agent
\item[] \texttt{groupId}: the \texttt{id} of the group this agent belongs to, if it is cohesive; \(-1\) otherwise
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getCapital()}
\item[] Returns the current capital of this agent.
\item[] Returns: the current capital of this agent

\item \texttt{int getInitialCapital()}
\item[] Returns the initial capital of this agent.
\item[] Returns: the initial capital of this agent

\item \texttt{void addCapital(int capital)}
\item[] Increases the captial of this agent by the given amount.

\item \texttt{Strategy getStrategy()}
\item[] Returns the current \texttt{Strategy} of this agent
\item[] Returns: the current \texttt{Strategy} of this agent

\item\texttt{void setStrategy(Strategy strategy)}
\item[] Sets the \texttt{Strategy} of this agent to the given one	.

\item \texttt{int getGroupId()}
\item[] Returns the \texttt{id} of the group this agent belongs to, if it is cohesive; \(-1\) otherwise.
\item[] Returns: the \texttt{id} of the group this agent belongs to, if it is cohesive; \(-1\) otherwise
\end{itemize}

\subsubsection{Interface \texttt{AgentPair}}
This interface represents a pair of agents.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{Agent getFirstAgent()}
\item[] Returns the first of both agents.
\item[] Returns: the first of both agents

\item \texttt{Agent getSecondAgent()}
\item[] Returns the second of both agents.
\item[] Returns: the second of both agents
\end{itemize}

\subsubsection{Class \texttt{GameResult}}

This class stores the result of a game between two agents. The result consists of:
\begin{itemize}\itemsep -10pt
	\item The agents involved
	\item The actions of the agents involved
	\item The received payments of the agents
\end{itemize}

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{GameResult(Agent player1, Agent player2, int payOff1, int payOff2, boolean hasCooperated1, boolean hasCooperated2)}
\item[] Creates a new \texttt{GameResult}.
\item[] \texttt{player1}: the first player
\item[] \texttt{player2}: the second player
\item[] \texttt{payOff1}: the received payoff of the first player
\item[] \texttt{payOff2}: the received payoff of the second player
\item[] \texttt{hasCooperated1}: \texttt{true} if the first player cooperated, \texttt{false} otherwise
\item[] \texttt{hasCooperated2}: \texttt{true} if the second player cooperated, \texttt{false} otherwise
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item  \texttt{boolean hasAgent(Agent agent)}
\item[] Returns whether the given agent was one of the players of this game.
\item[] \texttt{agent}: the agent that should be checked
\item[] Returns: \texttt{true} if the given agent was one of the players of this game, \texttt{false} otherwise

\item \texttt{int getPayoff(Agent agent)}
\item[] Returns the received payoff of the given agent in this game, if he was one of the players; \(0\) otherwise
\item[] \texttt{agent}: the agent whose payoff shall be returned
\item[] Returns: the received payoff of the given agent in this game, if he was one of the players; \(0\) otherwise

\item \texttt{boolean hasCooperated(Agent agent)}
\item[] Returns \texttt{true} if the given agent was one of the players of this game and cooperated, \texttt{false} otherwise.
\item[] \texttt{agent}: the agent whose cooperation shall be returned
\item[] Returns: \texttt{true} if the given agent was one of the players of this game and cooperated, \texttt{false} otherwise

\item \texttt{List<Agent> getAgents()}
\item[] Returns the two players of this game.
\item[] Returns: the two players of this game

\item \texttt{Agent getOtherAgent(Agent agent)}
\item[] If the given agent was one of the players of this game, returns the other player, otherwise returns \texttt{null}.
\item[] Returns: the other player, if the given agent was a player of this game, otherwise \texttt{null}
\end{itemize}

\subsubsection{Interface \texttt{Game}}
Extends: \texttt{Nameable}

This interface represents a game.

Methods:
\begin{itemize}\itemsep -10pt
\item[] \texttt{GameResult play(Agent player1, Agent player2, boolean player1Cooperates, boolean player2Cooperates)}
\item[] Lets two players with given cooperation decisions play this game against each other and returns the result of the game as \texttt{GameResult}.
\item[] \texttt{player1}: the first player
\item[] \texttt{player2}: the second player
\item[] \texttt{player1Cooperates}: \texttt{true} if the first player cooperates, \texttt{false} otherwise
\item[] \texttt{player2Cooperates}: \texttt{true} if the second player cooperates, \texttt{false} otherwise
\item[] Returns: the result of the game as \texttt{GameResult}
\end{itemize}

\subsubsection{Class \texttt{EngineSegment}}

This class represents a segment as used by the \texttt{AgentInitialiser}. It is characterized by the number of its agents, the \texttt{id} of the group to which its agents belong and its capital and strategy distribution.

Constructors:
\begin{itemize} \itemsep -10pt
	\item \texttt{EngineSegment(int agentCount, int groupId, DiscreteDistribution capitalDistribution, UniformFiniteDistribution<Strategy> strategyDistribution, boolean cohesive)}
	\item[] Creates a new \texttt{EngineSegment} with the given parameter set.
	\item[] \texttt{agentCount}: the number of agents in this segment
	\item[] \texttt{groupId}: the group id of agents in this segment
	\item[] \texttt{capitalDistribution}: the capital distribution which is used to initialise capital for the agents in this segment
	\item[] \texttt{strategyDistribution}: the strategy distribution which is used to initialise strategies for the agents in this segment
	\item[] \texttt{cohesiv}: indicates whether the group of the agents in this segment is cohesive or not
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getAgentCount()}
\item[] Returns the amount of agents in this segment.
\item[] Returns: the amount of agents in this segment

\item \texttt{int getGroupId()}
\item[] Returns the \texttt{id} of the group this segment is part of, if it is cohesive; \(-1\) otherwise.
\item[] Returns: the \texttt{id} of the group this segment is part of, if it is cohesive; \(-1\) otherwise

\item \texttt{DiscreteDistribution getCapitalDistribution()}
\item[] Returns the capital distribution of this segment
\item[] Returns: the capital distribution of this segment as \texttt{DiscreteDistribution}

\item \texttt{UniformFiniteDistribution<Strategy> getStrategyDistribution()}
\item[] Returns the strategy distribution of this segment
\item[] Returns: the strategy distribution of this segment as \texttt{UniformFiniteDistribution<Strategy>}
\end{itemize}

\subsubsection{Interface \texttt{PairBuilder}}
This interface represents a pairing algorithm. An implementation takes a set of agents as well as the history of the current adaptation step in the form of a \texttt{SimulationHistory} object and returns a matching of the agents.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{List<AgentPair> buildPairs(List<Agent> agents, SimulationHistory history)}
\item[] Builds pairs out of the given agents and returns them as \texttt{List<AgentPair>}.
\item[] \texttt{agents}: the agents that shall be paired
\item[] \texttt{history}: the \texttt{SimulationHistory} of the current adaption step
\item[] Returns: the built pairs as \texttt{List<AgentPair>}
\end{itemize}

\subsubsection{Class \texttt{RandomPairBuilder}}
Implements: \texttt{PairBuilder}

Realizes random pairing of the agents.

\subsubsection{Class \texttt{CooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realizes the \enquote{Paarbildung nach Wunsch} pairing described in the specification.

\subsubsection{Class \texttt{RandomCooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realizes the \enquote{Paarbildung nach Wunsch mit Zufall} pairing described in the specification.


Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{RandomCooperationConsideringPairBuilder(double randomnessFactor)}
\item[] Creates a new \texttt{RandomCooperationConsideringPairBuilder}.
\item[] \texttt{randomnessFactor}: the randomness factor; between \(0\) and \(1\)
\end{itemize}

\subsubsection{Interface \texttt{SuccessQuantifier}}

This interface represents a success quantification. An implementation takes a set of agents as well as the history of the current adaptation step in the form of a \texttt{SimulationHistory} object and creates a ranking of the agents based on their success in the past rounds. This one is returned as a list.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> createRanking(List<Agent> agents, SimulationHistory history)}
\item[] Creates and returns a ranking of the given agents.
\item[] \texttt{agents}: the agents that shall be ranked
\item[] \texttt{history}: the \texttt{SimulationHistory} of the current adaption step
\item[] Returns: the ranking as \texttt{List<Agent>}
\end{itemize}

\subsubsection{Class \texttt{TotalCapital}}
Implements: \texttt{SuccessQuantifier}

Realizes the \enquote{Absolutkapital} success quantification described in the specification

\subsubsection{Class \texttt{TotalPayoff}}
Implements: \texttt{SuccessQuantifier}

Realizes the \enquote{Absolutkapital ohne Initialkapital} success quantification described in the specification

\subsubsection{Class \texttt{SlidingMean}}
Implements: \texttt{SuccessQuantifier}

Realizes the \enquote{Gleitender Durchschnitt} success quantification described in the specification

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{SlidingMean(int windowSize)}
\item[] Creates a new \texttt{SlidingMean}-object with the given window size.
\item[] \texttt{windowSize}: the window size for the mean calculation
\end{itemize}

\subsubsection{Class \texttt{PayoffInLastAdapt}}
Implements: \texttt{SuccessQuantifier}

Realizes the \enquote{Auszahlung im letzten Adaptionsschritt} success quantification described in the specification

\subsubsection{Interface \texttt{StrategyAdjuster}}
This interface represents an adaptation mechanism. An implementation takes a ranked list of agents and adjusts the agents' strategies.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void adaptStrategies(List<Agent> agents, SimulationHistory hist)}
\item[] Adjusts the strategies of the given agents considering the current simulation history.
\item[] \texttt{agents}: the agents whose strategies shall be adapted, ordered by their success in the current adaption step
\item[] \texttt{hist}: the current simulation history
\end{itemize}

\subsubsection{Class \texttt{ReplicatorDynamic}}
Implements: \texttt{StrategyAdjuster}

Realizes the \enquote{Replicator Dynamic} adjustment mechanism described in the specification.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{ReplicatorDynamic(double alpha, double delta)}
\item[] Creates a new \texttt{ReplicatorDynamic}-object with the given parameters \(\alpha\) and \(\delta\).
\item[] \texttt{alpha}: the comparing probability
\item[] \texttt{delta}: the adjusting probability
\end{itemize}

\subsubsection{Class \texttt{PreferentialAdaption}}
Implements: \texttt{StrategyAdjuster}

Realizes the \enquote{Preferential Adaption} adjustment mechanism described in the specification.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{PreferentialAdaption(double alpha, double delta)}
\item[] Creates a new \texttt{PreferentialAdaption}-object with the given parameters \(\alpha\) and \(\delta\).
\item[] \texttt{alpha}: the comparing probability
\item[] \texttt{delta}: the adjusting probability
\end{itemize}

\subsubsection{Interface \texttt{EquilibriumCriterion}}

This interface represents an equilibrium criterion. At the end of an adaptation step, an implementation of this one receives a list of the agents, ordered by rank, and the course of the adaptation step in the form of a \texttt{SimulationHistory} object, and returns whether or not there has been a balance.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{boolean isEquilibrium(List<Agent> agents, SimulationHistory history)}
\item[] Returns whether an equilibrium is reached.
\item[] \texttt{agents}: the agents of the currently simulated iteration
\item[] \texttt{history}: the \texttt{SImulationhistory} of the current adaption step
\item[] Returns: \texttt{true} if an equilibrim is reached, \texttt{false} otherwise
\end{itemize}

\subsubsection{Abstract Class \texttt{CountingEquilibriumCriterion}}
Implements: \texttt{EquilibriumCriterion}

This class represents an equilibrium criterion, that each round checks a certain condition and recognizes an equilibrium, if this condition is fulfilled for a certain number of consecutive adaptation steps. This condition and the necessary number of consecutive adaptation steps are implemented as template methods.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{abstract boolean hasEquilibriumCondition(List<Agent> agents, SimulationHistory history)}
\item[] Returns whether the equilibrium condition is met for the current adaption step
\item[] \texttt{agents}: the agents of the currently simulated iteration
\item[] \texttt{history}: the \texttt{SimulationHistory} of the current adaption step
\item[] Returns: \texttt{true} if the condition is met, \texttt{false} otherwise

\item \texttt{abstract boolean longEnough(int steps)}
\item[] Returns whether \texttt{steps} is larger or equal to the minimum amount of consecutive condition-meeting adaption steps.
\item[] \texttt{steps}: the amount of adaption steps that shall be checked
\item[] Returns: \texttt{true} if \texttt{steps} is sufficiently large, \texttt{false} otherwise
\end{itemize}

\subsubsection{Class \texttt{StrategyEquilibrium}}
Implements: \texttt{CountingEquilibriumCriterion}

Realize the \enquote{Strategie-Gleichgewichtskriterium} described in the specification.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{StrategyEquilibrium(double alpha, int minRounds)}
\item[] Creates a new \texttt{StrategyEquilibrium}-object with the given parameters.
\item[] \texttt{alpha}: the strictness of the equilibrium
\item[] \texttt{minRounds}: the minimum amount of consecutive condition-meeting adaption steps
\end{itemize}

\subsubsection{Class \texttt{RankingEquilibrium}}
Implements: \texttt{CountingEquilibriumCriterion}

Realize the \enquote{Rang-Gleichgewichtskriterium} described in the specification.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{RankingEquilibrium(double alpha, int minRounds)}
\item[] Creates a new \texttt{RankingEquilibrium}-object with the given parameters.
\item[] \texttt{alpha}: the strictness of the equilibrium
\item[] \texttt{minRounds}: the minimum amount of consecutive condition-meeting adaption steps
\end{itemize}

\subsection{Package \texttt{edu.kit.loop.model.simulationengine.strategies}}
This package contains the interface \texttt{Strategy}, which represents a game theory strategy, as well as some implementations.


\subsubsection{Interface \texttt{Strategy}}
Extends: \texttt{Nameable}

Represents a strategy. This may or may not be mixed.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{boolean isCooperative(Agent player, Agent opponent, SimulationHistory history)}
\item[] Returns whether agent \texttt{player} would cooperate in a game against agent \texttt{opponent} using this strategy, given the \texttt{SimulationHistory} of the current adaption step. If the strategy is non-deterministic, the result may be random.
\item[] Returns: if agent \texttt{player} cooperates

\item \texttt{double getCooperationProbability(Agent player, Agent opponent, SimulationHistory history)}
\item[] Returns the probability with which agent \texttt{player} would cooperate in a game against agent \texttt{opponent} using this strategy, given the \texttt{SimulationHistory} of the current adaption step.
\item[] Returns: the probability with which agent \texttt{player} would cooperate in a game against agent \texttt{opponent} using this strategy, given the \texttt{SimulationHistory} of the current adaption step
\end{itemize}

\subsubsection{Class \texttt{PureStrategy}}
Implements: \texttt{Strategy, java.io.Serializable}

This class represents a pure strategy. This is uniquely determined by a condition on the enemy agent based on the history of the simulation, represented as \texttt{BiPredicate <Agent, SimulationHistory>}.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{PureStrategy(BiPredicate<Agent,SimulationHistory> condition)}
\item[] Creates a new \texttt{PureStrategy}.
\item[] \texttt{condition}: the condition an opposing agent must meet in order for an agent using this strategy to cooperate in a game against him
\end{itemize}

\subsubsection{Class \texttt{MixedStrategy}}
Implements: \texttt{Strategy}, \texttt{RealVector}

This class represents a mixed strategy that is composed of multiple \texttt{Strategy}s, each one chosen with a certain probability on every evaluation. It also implements the functionality of a \texttt{RealVector} with the probabilities of the different \texttt{Strategy}s as components.

Constructors://vorläufig
\begin{itemize}\itemsep -10pt
\item[] //wirft exception wenn listen nicht gleichlang oder wahrsch. ungültig (alle positiv und in summe 1)
\item \texttt{MixedStrategy(List<Strategy> strategies, List<double> probabilites)}
\item[] Creates a new \texttt{MixedStrategy} consisting of the given \texttt{Strategy}s with the given probabilities.
\item[] \texttt{strategies}: the \texttt{Strategy}s this mixed strategy consists of
\item[] \texttt{probabilities}: the probabilities of the given \texttt{Strategy}s
\end{itemize}

\subsubsection{Interface \texttt{Vector<T>}}
This interface represents a vector of fixed size holding entities of type \texttt{T}. An implementation allows retrieving and overwriting vector components and offers a cloning function.

Parameters:
\begin{itemize}\itemsep -10pt
\item \texttt{<T>} the type of the components of the vector
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getSize()}
\item[] Returns the size of the vector.
\item[] Returns: the size of the vector

\item \texttt{T getComponent(int index)}
\item[] Returns the component at the given index.
\item[] \texttt{index}: the index of the component that shall be returned
\item[] Returns: the component at the given index

\item \texttt{void setComponent(int index, T value)}
\item[] Set the component at the given index to the given value
\item[] \texttt{index}: the index of the component that shall be set to the given value
\item[] \texttt{value}: the value that the component at given index shall be set to

\item \texttt{Vector<T> clone()}
\item[] Returns a clone of the vector
\item[] \texttt{<T>} the type of the components of the vector
\item[] Returns: a clone of the vector
\end{itemize}

\subsubsection{Interface \texttt{RealVector}}
Extends: \texttt{Vector<double>}

This interface extends the \texttt{Vector<double>}
-interface as a vector that has only real components. It offers additional functionality such as the calculation of euclidean or sum norm or the multiplication by real scalars and the addition with other \texttt{RealVector}s.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{double getEuclideanNorm()}
\item[] Returns the euclidean norm of the vector.
\item[] Returns: the euclidean norm of the vector

\item \texttt{double getSumNorm()}
\item[] Returns the sum norm of the vector
\item[] Returns: the sum norm of the vector

\item \texttt{void multiplyBy(double scalar)}
\item[] Multiplies the vector by the given scalar.
\item[] \texttt{scalar}: the real scalar this vector shall be multiplied by

\item \texttt{void add(RealVector vector)}
\item[] Adds the given vector to this vector.
\item[] \texttt{vector}: the vector that shall be added to this vector
\end{itemize}

\subsubsection{Interface \texttt{Operator}}

This interface represents a logical operator for combining strategies to generate a new strategy

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{Strategy combineStrategies(Strategy strat1, Strategy strat2)}
	\item[] This method creates a new \texttt{Strategy}-instance by combining the given strategies
	\item[] \texttt{strat1}: the first strategy to combine
	\item[] \texttt{strat2}: the second strategy to combine
	\item[] Returns: the combined strategy

	\item \texttt{int getOperandCount()}
	\item[] This method returns the number of expected operands
	\item[] Returns: the number of operands
\end{itemize}

\subsubsection{Class \texttt{AndOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{AND} operator

\subsubsection{Class \texttt{NandOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{NAND} operator

\subsubsection{Class \texttt{OrOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{OR} operator

\subsubsection{Class \texttt{NorOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{NOR} operator

\subsubsection{Class \texttt{XorOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{XOR} operator

\subsubsection{Class \texttt{ImpliesOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by combining the given ones with a logical \texttt{IMPLIES} operator

\subsubsection{Class \texttt{NotOperator}}

Implements: \texttt{Operator}

This class is an operator that creates a new \texttt{Strategy} by negating the given one

\subsubsection{Interface \texttt{TreeNode<T>}}

This interface represents a node in a hierarchic structure. It can store a generic content and provides functionality to insert and remove children to create a tree like structure.

\subsubsection{Interface \texttt{TreeNode<T>}}

This interface represents a node in a hierarchic structure. It can store a generic content and provides functionality to insert and remove children to create a tree like structure.

Parameter:
\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} the type of the content that shall be stored in the Node
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{T getContent()}
	\item[] This method returns the content saved in this node
	\item[] Returns: the node's content

	\item \texttt{List<TreeNode<T>\,> getChildren()}
	\item[] This method returns all children of this tree node
	\item[] Returns: a list of all children

	\item \texttt{void insertNode(TreeNode<T> node)}
	\item[] This method inserts the given node as a child to this node
	\item[] \texttt{node}: the node to insert as a child

	\item \texttt{boolean removeNode(TreeNode<T> node)}
	\item[] This method removes the given node from this node's children
	\item[] \texttt{node}: the node that shall be removed
	\item[] Returns: \texttt{true} if the node was removed, \texttt{false} otherwise
\end{itemize}

\subsubsection{Class \texttt{SyntaxNode implements TreeNode<Strategy>}}

This class represents a tree node in a syntax tree for combined strategies. In case of a leaf node it stores the strategy that shall be combined otherwise in case of an inner node it stores an operator to combine strategies.

Constructors:
\begin{itemize} \itemsep -10pt
	\item \texttt{SyntaxNode(Strategy strat, Operator op)}
	\item[] Creates a new \texttt{SyntaxNode}-instance
	\item[] \texttt{strat}: the strategy that shall be stored in this node
	\item[] \texttt{op}: the operator that shall be stored in this node
\end{itemize}

Methods:
\begin{itemize} \itemsep -10pt
	\item \texttt{Operator getOperator()}
	\item[] This method returns the operator stored in this node
	\item[] Returns: the operator stored by this node

	\item \texttt{boolean isInnerNode()}
	\item[] This method returns whether the node is an inner node or not
	\item[] Returns: \texttt{true} when the node is an inner node, otherwise  \texttt{false} when the node is a leaf node
\end{itemize}

\subsubsection{Interface \texttt{Tree<T>}}

This interface represents a graph with tree structure which contains of \texttt{TreeNode<T>}-instances

Parameters:
\begin{itemize} \itemsep -10pt
	\item \texttt{<T>} the type of the tree's node content (resp. the generic type of \texttt{TreeNode<T>})
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{TreeNode<T> getRoot()}
	\item[] This method returns the root of the tree
	\item[] Returns: the root of the tree
\end{itemize}

\subsubsection{Class \texttt{SyntaxTree implements Tree<Strategy>}}

This class is an implementation of the \texttt{Tree<T>}-interface using \texttt{SyntaxNode}s to create more complex logical combinations of strategies. Additionally it provides functionality to validate the syntactical correctness of the syntax tree and to get the smallest faulty sub tree in case of a syntactical error.

Constructors:
\begin{itemize}\itemsep -10pt
	\item \texttt{SyntaxTree(SyntaxNode root)}
	\item[] Creates a new \texttt{SyntaxTree}-instance with the given node as root element
	\item[] \texttt{root}: the node element which shall be the root of the tree
\end{itemize}

Methods:
\begin{itemize} \itemsep -10pt
	\item \texttt{boolean checkSyntax()}
	\item[] This Method checks whether the expression represented by this tree is syntactical correct or not
	\item[] Returns: \texttt{true} when the syntax is correct \texttt{false} otherwise

	\item \texttt{SyntaxNode getFaultyNode()}
	\item[] This method returns the root of the smallest sub tree with an incorrect syntax
	\item[] Returns: the root of the faulty sub tree
\end{itemize}

\subsubsection{Class \texttt{StrategyBuilder}}

This class provides functionality to create a new strategy from a given root \texttt{SyntaxNode} of a syntax tree by combining strategies to generate the corresponding expression.

Methods:
\begin{itemize} \itemsep -10pt
	\item \texttt{static Strategy createNewStrategy(SyntaxNode root, String name, String desc)}
	\item[] This method creates a new \texttt{Strategy} from a given root
	\item[] \texttt{root}: the root of the syntax tree the \texttt{Strategy} shall be built from
	\item[] \texttt{name}: the name of the \texttt{Strategy} to create
	\item[] \texttt{desc}: the description of the \texttt{Strategy} to create
	\item[] Returns: the newly created \texttt{Strategy} or \texttt{null} when there is a syntactical error
\end{itemize}


\subsection{Package \texttt{edu.kit.loop.model.simulationengine.distributions}}

This package contains functionality for generating different types of distributions and for randomly picking values from those distributions.

\subsubsection{Interface \texttt{Distribution<E>}}
This interface represents a probability distribution over a carrier of objects of type \texttt{E}. An implementation returns the probability of a particular object upon request, and provides a \texttt{Picker <E>} to randomly pull objects from the probability distribution.

Methods
\begin{itemize}\itemsep -10pt
\item \texttt{double getProbability(E object)}
\item[] Returns the probability of the given object in this distribution.
\item[] \texttt{element}: the object whose probability shall be returned
\item[] Returns: the probability of the given object in this distribution

\item \texttt{Picker<E> getPicker()}
\item[] Returns a \texttt{Picker<E>} for this probability distribution.
\item[] Returns: a \texttt{Picker<E>} for this probability distribution
\end{itemize}

\subsubsection{Interface \texttt{Picker<E>}}
A \texttt{Picker <E>} is provided by implementations of the \texttt{Distribution <E>} interface to drag objects from the associated probability distribution.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{E pickOne()}
\item[] Picks an object out of the probability distribution and returns it.
\item[] Returns: the picked object

\item \texttt{List<E> pickMany(int i)}
\item[] Picks multiple elements out of the probability distribution and returns them as \texttt{List<E>} zurück.
\item[] \texttt{i}: the amount of elements that shall be picked
\item[] Returns: the picked objects as \texttt{List<E>}
\end{itemize}

\subsubsection{Interface \texttt{DiscreteDistribution}}
Extends: \texttt{Distribution<Integer>}

Represents a discrete probability distribution on integers. An implementation calculates an interval for a given value \(q \ in (0,1) \) \(I_q = [a, b] \) (\(a, b \ in \ mathbb {Z}, a < b \)), so that a randomly drawn value from the distribution is at least with the probability \(q \) in \(I_q \). The limits of this interval can be queried.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{int getSupportMin(double q)}
\item[] Returns the lower bound of \(I_q\).
\item[] \texttt{q}: the value \(q\) for the determination of the interval \(I_q\)
\item[] Returns: the lower bound of \(I_q\)

\item \texttt{int getSupportMax(double q)}
\item[] Returns the upper bound of \(I_q\).
\item[] \texttt{q}: the value \(q\) for the determination of the interval \(I_q\)
\item[] Returns: the upper bound of \(I_q\)
\end{itemize}

\subsubsection{Class \texttt{PoissonDistribution}}
Implements: \texttt{DiscreteDistribution}

Represents a Poisson distribution.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{PoissonDistribution(double lambda)}
\item[] Creates a new \texttt{PoissonDistribution} with given parameter \texttt{lambda}.
\item[] \texttt{lambda}: the variable parameter of a poisson distribution
\end{itemize}

\subsubsection{Class \texttt{BinomialDistribution}}
Implements: \texttt{DiscreteDistribution}

Represents a bionomial distribution.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{BinomialDistribution(int min, int max, double p)}
\item[] Creates a new \texttt{BinomialDistribution} with the given parameters.
\item[] \texttt{min}: the lower bound of the distribution
\item[] \texttt{max}: the upper bound of the distribution
\item[] \texttt{p}: the probability parameter \(p \in [0,1]\) of the binomial distribution
\end{itemize}

\subsubsection{Class \texttt{DiscreteUniformDistribution}}
Implements: \texttt{DiscreteDistribution}

Represents a discrete equal distribution.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{DiscreteUniformDistribution(int min, int max)}
\item[] Creates a new \texttt{DiscreteUniformDistribution} with the given parameters
\item[] \texttt{min}: the lower bound of the distribution
\item[] \texttt{max}: the upper bound of the distribution
\end{itemize}

\subsubsection{Interface \texttt{FiniteDistribution<E>}}

Extends: \texttt{Distribution<E>}

Represents a probability distribution over objects of type \texttt{E} with finite carrier. Implementations return the carrier on query as \texttt{List<E>}.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{List<E> getSupport()}
\item[] Returns the support of this probability distribution.
\item[] Returns: the support of this distribution
\end{itemize}

\subsubsection{Class \texttt{UniformFiniteDistribution<E>}}
Implements: \texttt{FiniteDistribution<E>}

Represents a uniform distribution over objects of type \texttt{E} with finite carrier. Implementations provide methods for adding and removing objects.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{UniformFiniteDistribution<E>()}
\item[] Creates a new \texttt{UniformFiniteDistribution<E>} with empty support.

\item \texttt{UniformFiniteDistribution<E>(List<E> objects)}
\item[] Creates a new \texttt{UniformFiniteDistribution<E>} with the given objects as support.
\item[] \texttt{objects}: the objects the support of this distribution consists of
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void addObject(E object)}
\item[] Adds the given object to the support.
\item[] \texttt{object}: the object thta shall be added

\item \texttt{void addObjects(List<E> objects)}
\item[] Adds the given objects to the support.
\item[] \texttt{objects}: the objects that shall be added

\item \texttt{boolean deleteObject(E object)}
\item[] Removes the given object from the support, if contained.
\item[] \texttt{object}: the object that shall be removed
\item[] Returns: \texttt{true} if the given object was contained and successfully removed, \texttt{false} otherwise
\end{itemize}

\subsection{Package \texttt{edu.kit.loop.Controller}}

\subsubsection{Class \texttt{HeadController}}
This class represents the controller associated with the main window. It defines the interface between the model and the controller structure. It is mainly responsible for starting simulations by providing \texttt{UserConfiguration}s to the simulator and for delegating further task to the other controllers.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the HeadController and it's databindings with the UI
\end{itemize}

\subsubsection{Class \texttt{HistoryController}}
This class represents the controller responsible for the simulation history. It stores a list of SimulationResults of all executed simulations.
the
Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void addSimulation(SimulationResult result)}
\item[] Adds a simulation result to the simulation history
\item[] \texttt{result}: the SimulationResult that shall be added

\item \texttt{SimulationResult getSelectedSimulation()}
\item[] Returns the currently selected simulation result
\item[] Returns: the currently selected SimulationResult

\item \texttt{List<SimulationResult> getAllSimulations()}
\item[] Return all the simulations in the history
\item[] Returns: a list of all SimulationResults in the history
\end{itemize}

\subsubsection{Class \texttt{OutputController}}
This class represents the controller responsible for the output of simulation results in the main window.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void addSimulation(SimulationResult result)}
\item[] Adds a simulation's result to the output
\item[] \texttt{result}: the SimulationResult which shall be added

\end{itemize}

\subsubsection{Class \texttt{DetailedOutputController}}
This class represents the controller responsible for the detailed output of a simulation's result.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialises()}
\item[] initialises the DetailedOutputController and it's databindings with the UI
\end{itemize}

\subsubsection{Class \texttt{AbstractedOutputController}}
This class represents the controller responsible for the abstracted output of a simulation's result.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the AbstractedOutputController and it's databindings with the UI.
\end{itemize}

\subsubsection{Class \texttt{MultiConfigOutputController}}
This class represents the controller responsible for the output of a simulation's result which featured a multi configuration.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the MultiConfigOutputController and it's databindings with the UI.
\end{itemize}

\subsubsection{Interface \texttt{CreationController<T>}}

This interface provides functionality to observe the controller for new entity creations by registering a callback. It gets implemented by all controllers which are associated with creation windows.

Parameter:
\begin{itemize} \itemsep -10pt
	\item \texttt{<T>}: the type of the entity created by the controller
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void registerElementCreated(Consumer<T> action)}
\item[] Registers a callback which gets invoked whenever a new entity has been created and passes the newly created entity to it.
\item[] \texttt{action}: the callback which shall be registered
\end{itemize}

\subsubsection{Class \texttt{GroupController}}
This class represents the controller responsible for the group creation window. It creates new groups based on the user input and informs the \texttt{HeadController}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the GroupController and it's databindings with the UI.
\end{itemize}

\subsubsection{Class \texttt{PopulationController}}
This class represents the controller responsible for the population creation window. It creates new populations based on the user input and informs the \texttt{HeadController}.

Constructors:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the PopulationController an it's databindings with the UI.
\end{itemize}

\subsubsection{Class \texttt{NewGameController}}
This class represents the controller responsible for the game creation window.
It creates new games based on the user input and informs the \texttt{HeadController} about it.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the NewGameController an it's databindings with the UI.
\end{itemize}

\subsubsection{Class \texttt{NewSrategyController}}
This class represents the controller responsible for the strategy creation window. It creates new strategies based on the user input and informs the \texttt{HeadController} about it.

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the NewStrategyController an it's databindings with the UI.
\end{itemize}

\subsubsection{Class \texttt{ConfigController}}

Implements: \texttt{CreationController<UserConfiguration>}

This class represents the controller responsible for the configuration window. It creates new \texttt{UserConfiguration}s from user input and informs the HeadController when a new \texttt{UserConfiguration} has been created.

Controller:
\begin{itemize}\itemsep -10pt
\item \texttt{ConfigController(UserConfiguration configuration)}
\item[] Creates a new ConfigController with the given configuration.
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
\item \texttt{void initialise()}
\item[] initialises the ConfigController an it's databindings with the UI.

\item \texttt{void setConfiguration(Userconfiguration configuration)}
\item[] Sets the parameters to the given configuration

\end{itemize}

\subsection{Package \texttt{edu.kit.loop.model.plugin}}

This package contains the functionality involved in creating and loading new plugins which extend the simulation process.

\subsubsection{Class \texttt{PluginLoader}}

This class provides the functionality to dynamically load plugins at run time using the Java \texttt{ServiceLoader}-API.

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{static <T> List<T> loadPlugins()}
	\item[] loads all available plugins of the given type \texttt{T}
	\item[] \texttt{<T>} the type of the plugins that shall be loaded
	\item[]Returns: a list of the loaded plugins
\end{itemize}

\subsubsection{abstract Class \texttt{PluginControl}}
Extends: \texttt{javafx.scene.layout.Pane}

This class serves as a control for the configuration of a plugin. It provides functionality for querying the configuration parameters entered by the user.

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{abstract List<double> getParameters()}
	\item[] Returns a list of the entered parameter values for the plugin configuration
	\item[] Returns: a list of the entered parameter values for the plugin configuration
\end{itemize}

\subsubsection{Class \texttt{TextFieldPluginControl}}
Extends: \texttt{PluginControl}

This class is an implementation of a \texttt{PluginControl}, where the configuration parameters are entered via text fields. The input is still checked for correctness.

Constructors:

\begin{itemize}\itemsep -10pt
	\item \texttt{TextFieldPluginControl(List<Parameter> params)}
	\item[] Creates a new \texttt{TextFieldPluginControl}.
	\item[] \texttt{params}: a list of all configurable \texttt{Parameter}s
\end{itemize}

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{void addParameter(Parameter param)}
	\item[] Adds a \texttt{Parameter}, which is then configurable with this control element
	\item[] \texttt{param}: the \texttt{Parameter} that shall be added
	\item \texttt{void addParameters(List<Parameter> params)}
	\item[] Adds a list of \texttt{Parameter}s, which are then configurable with this control element
	\item[] \texttt{params}: the \texttt{Parameter}s that shall be added
\end{itemize}

\subsubsection{Interface \texttt{PluginRenderer}}

This interface provides the functionality to create a plugin configuration control which can be dynamically embedded into a javafx-Window at run time.

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{PluginControl render()}
	\item[] Returns a \texttt{PluginControl}-instance, which can be added to a JavaFX-window.
	\item[] Returns: a \texttt{PluginControl}-instance, which can be added to a JavaFX-window
\end{itemize}

\subsubsection{Class \texttt{GenericRenderer}}
Implements: \texttt{PluginRenderer}

This class implements the \texttt{PluginRenderer} interface and creates a generic text-based configuration control (\texttt{TextFieldPluginControl} instance) for any plug-in.

Constructors:

\begin{itemize}\itemsep -10pt
	\item \texttt{GenericRenderer(Plugin plugin)}
	\item[] Creates a new \texttt{GenericRenderer} for the given plugin
	\item[] \texttt{plugin}: the \texttt{Plugin} which shall be rendered by this \texttt{GenericRenderer}

	\item \texttt{GenericRenderer(List<Parameter> params)}
	\item[] Creates a new \texttt{GenericRenderer} for a plugin with the given parameters
	\item[] \texttt{params}: a list with the \texttt{Parameter}s of the \texttt{Plugin} that shall be rendered by this \texttt{GenericRenderer}
\end{itemize}

\subsubsection{Class \texttt{Parameter}}
Implements: \texttt{Nameable}

This class defines a configuration parameter for plugins. It provides functionality to set the value range and granularity of the configuration parameter.

Constructors:
\begin{itemize}\itemsep -10pt
	\item \texttt{Parameter()}
	\item[] Creates a new unbounded \texttt{Parameter}.

	\item \texttt{Parameter(double minVal, double maxVal)}
	\item[] Creates a new bounded \texttt{Parameter}
	\item[] \texttt{minVal}: the lower bound of the \texttt{Parameter}
	\item[] \texttt{maxVal}: the upper bound of the \texttt{Parameter}
	\item \texttt{Parameter(double minVal, double maxVal, double stepSize)}
	\item[] Creates a new unbounded \texttt{Parameter} with constricted granularity
\item[] \texttt{minVal}: the lower bound of the \texttt{Parameter}
	\item[] \texttt{maxVal}: the upper bound of the \texttt{Parameter}
	\item[] \texttt{stepSize}: the granularity of the parameter

\end{itemize}

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{double getMinValue()}
	\item[] Returns the lower bound of this parameter.
	\item[] Returns: the lower bound of this parameter (\texttt{Double.NEGATIVE\_INFINITY} if unbounded)
	\item \texttt{double getMaxValue()}
	\item[] Returns the upper bound of this parameter.
	\item[] Returns: the upper bound of this parameter (\texttt{Double.POSITIVE\_INFINITY} if unbounded)
	\item \texttt{double getStepSize()}
	\item[] Returns the granularity of this parameter
	\item[]Returns: the granularity of this parameter (\(0\) if no constraint)
\end{itemize}

\subsubsection{Class \texttt{ParameterValidator}}

This class provides functionality for validating a parameter assignment in the form of static auxiliary methods.

Methods:

\begin{itemize} \itemsep -10pt
	\item \texttt{static boolean isValueValid(double val, Parameter param)}
	\item[] Checks if the given value is a valid assignment for the given parameter
	\item[] \texttt{val}: the value that shall be checked
	\item[] \texttt{param}: the parameter whose value range shall be considered
	\item[] Returns: \texttt{true} if the given value lies in the value range of the given parameter, \texttt{false} otherwise
	\item \texttt{static double getClosestValid(double val, Parameter param)}
	\item[] Returns the value in the value range of the given parameter that is closest to the given value.
	\item[] \texttt{val}: the value that shall be considered
	\item[] \texttt{param}: the parameter whose value range shall be considered
	\item[] Returns: the value in the value range of the given parameter that is closest to the given value
\end{itemize}

\subsubsection{Abstract Class \texttt{Plugin<T>}}
Implements: \texttt{Nameable}

This class represents a dynamically loadable plugin. It is a generic container for another class that implements the actual plugin functionality. It provides functions for creating new parameterized instances of the wrapped class. A list of required configuration parameters can be queried.

Parameter:
\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} Der Typ der Klasse, welche die Pluginfunktionalität bereit stellt.
\end{itemize}

Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{PluginRenderer getRenderer()}
	\item[] Returns a \texttt{PluginRenderer}-instance for this plugin
	\item[] Returns: a \texttt{PluginRenderer}-instance for this plugin

	\item \texttt{abstract List<Parameter> getParameters()}
	\item[] Returns a list of the configuration parameters of this plugin
	\item[] Returns: a list of the configuration parameters of this plugin

	\item \texttt{abstract T getNewInstance(List<double> params)}
	\item[] Creates and returns a new instance of the functionality holding class of this plugin with the given values as parameters
	\item[] \texttt{params}: a list with the values of the configuration \texttt{Parameter}s
	\item[] Returns: the newly created and parametrised instance of the funcitonaliy holding class
\end{itemize}

\subsection{Package \texttt{edu.kit.loop.model.repository}}

This package contains the functionality of the central repositories, through which all currently available games, strategies, populations as well as pairing algorithms, success quantifications, adaptation mechanisms, equilibrium criteria and discrete distributions can be obtained.


\subsubsection{Interface \texttt{Repository<T>}}

A repository stores an association of names and entities and makes them available on request.

Parameters:
\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} the type of the entities that shall be stored in this repository
\end{itemize}


Methods:
\begin{itemize}\itemsep -10pt
	\item \texttt{T getEntityByName(String name)}
	\item[] Returns the entity with the given name, if currently stored; \texttt{null} otherwise
	\item[] \texttt{name}: the name of the entity that shall be returned
	\item[] Returns: the entity with the given name if stored; \texttt{null} otherwise

	\item \texttt{boolean addEntity(String name, T entity)}
	\item[] Adds a new entity with the given name to the repository, if no entity with the given name is already stored.
	\item[] \texttt{name}: the name of the entity that shall be added
	\item[] \texttt{entity}: the entity that shall be added
	\item[] Returns: \texttt{true} if the entity was successfully added, \texttt{false} otherwise

	\item \texttt{boolean containsEntityName(String name)}
	\item[] Returns whether this repository contains an entity with the given name
	\item[] \texttt{name}: the name that shall be checked
	\item[] Returns: \texttt{true} if an entity with the given name is stored, \texttt{false} otherwise

	\item \texttt{List<String> getAllEntityNames()}
	\item[] Returns all entity keys used in this repository
	\item[] Returns: a list of all entity keys

\end{itemize}

\subsubsection{Class \texttt{HashMapRepository}}

Implements: \texttt{Repository<T>}

An implementation of the \texttt{Repository<T>}- interface that stores entities in a \texttt{HashMap}.

Parameters:

\begin{itemize}\itemsep -10pt
	\item \texttt{<T>} the type of the entities that shall be stored in this repository
\end{itemize}

Constructors:

\begin{itemize} \itemsep -10pt
	\item \texttt{HasMapRepository()}
	\item[] Creates a new \texttt{Repository}.
\end{itemize}

\subsubsection{Class \texttt{CentralRepository}}

This class provides central access to all loaded Plugins of all types as well as strategies, games, populations and groups loaded from files. It provides getters which return \texttt{Repository<T>}-instances for all entity types. This class is implemented as a singleton and therefore can be safely inherited from.

Methods:

\begin{itemize} \itemsep -10pt
	\item \texttt{static void initialise()}
	\item[] initialises the Repository-instance by loading all available plugins in the current execution environment working directory and all saved entities from the home directory.
	\item \texttt{static CentralRepository getInstance()}
	\item[]Returns the singleton Repository-instance
	\item[] Returns: the singleton instance
	\item \texttt{Repository<Strategy> getStrategyRepository()}
	\item[]Returns the repository containing all currently loaded strategies
	\item[] Returns: the strategy repository
	\item \texttt{Repository<Game> getGameRepository()}
	\item[]Returns the repository containing all currently loaded games
	\item[] Returns: the game repository
	\item \texttt{Repository<Population> getPopulationRepository()}
	\item[]Returns the repository containing all currently loaded populations
	\item[] Returns: the population repository
	\item \texttt{Repository<Group> getGroupRepository()}
	\item[]Returns the repository containing all currently loaded groups
	\item[] Returns: the group repository
	\item \texttt{Repository<Plugin<EquilibriumCriterion>\,> getEquilibriumCriterionRepository()}
	\item[]Returns the repository containing all currently loaded \texttt{EquilibriumCriterion}-plugins
	\item[] Returns: the equilibrium criterion repository
	\item\texttt{Repository<Plugin<SuccessQuantifier>\,> getSuccessQuantifiernRepository()}
	\item[]Returns the repository containing all currently loaded \texttt{SuccessQuantifier}-plugins
	\item[] Returns: the success quantifier criterion repository
	SuccessQuantifier
	\item\texttt{Repository<Plugin<StrategyAdjuster>\,> getStrategyAdjusterRepository()}
	\item[]Returns the repository containing all currently loaded \texttt{StrategyAdjuster}-plugins
	\item[] Returns: the strategy adjuster repository
	\item\texttt{Repository<Plugin<PairBuilder>\,> getPairBuilderRepository()}
	\item[]Returns the repository containing all currently loaded \texttt{PairBuilder}-plugins
	\item[] Returns: the pair builderrepository
	\item\texttt{Repository<Plugin<DiscreteDistribution>\,> getDiscreteDistributionRepository()}
	\item[]Returns the repository containing all currently loaded \texttt{DiscreteDistribution}-plugins
	\item[] Returns: the success discrete distribution repository
\end{itemize}

\subsubsection{Class \texttt{FileIO}}

This class provides static functionality for loading and storing entities in files.

Methods:

\begin{itemize}\itemsep -10pt
	\item \texttt{static <T> T loadEntity(File file)}
	\item[] Loads an entity of type \texttt{T} out of the given file.
	\item[] \texttt{<T>} the type of the entity that shall be loaded
	\item[] \texttt{file}: the file from which the entity shall be loaded
	\item[]Returns: the loaded entity or \texttt{null} if no entity could be loaded
	\item[]Throws: \texttt{FileNotFoundException} when the given file doesn't exist
	\item[]Throws: \texttt{IOException} when the entity can not be deserialized

	\item \texttt{static <T> List<T> loadAllEntities(File dir)}
	\item[] Loads all entities of type \texttt{T} from files in the given directory
	\item[] \texttt{<T>} the type of the entity that shall be loaded
	\item[] \texttt{dir}: the directory from which the entities shall be loaded
	\item[]Returns: a list of all loaded entities
	\item[]Throws: \texttt{FileNotFoundException} when the given directory doesn't exist

	\item \texttt{static <T> List<T> loadAllEntities(List<File> files)}
	\item[] Loads all entities of type \texttt{T} from the given files.
	\item[] \texttt{<T>} the type of the entity that shall be loaded
	\item[] \texttt{files}: the list of all files from which entities shall be loaded
	\item[]Returns: a list of all loaded entities
	\item[]Throws: \texttt{FileNotFoundException} when any of the given files doesn't exist

	\item \texttt{static <T> boolean saveEntity(File file, T entity)}
	\item[] Saves the given entity in the given file.
	\item[] \texttt{<T>} the type of the entity that shall be saved
	\item[] \texttt{file}: the file to which the entity shall  be saved
	\item[] \texttt{entity}: the entity that shall be saved
	\item[]Returns: \texttt{true} if the saving process finished successfully, \texttt{false} otherwise
	\item[] Throws: \texttt{IOException} when the given entity can not be serialized or the given file doesn't exist and can not be created
\end{itemize}

\section{Glossary}
\textbf{Elementary configuration:}

A configuration in which multiconfiguration is disabled. In the case of a multiconfiguration, the set of elementary configurations is the set of all elementary configurations in which the multiconfiguration parameter passes through the specified set of values. In the case of an elementary configuration, the configuration itself is meant again.

\end{document}
