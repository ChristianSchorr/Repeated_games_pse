\documentclass[parskip=full,11pt]{scrartcl}
\usepackage[utf8]{inputenc}

%\title{Simulator für wiederholte Spiele}
%\author{Sebastian Feurer, Peter Koepernik, Luc Mercatoris,\\Christian Schorr, Pierre Toussing}

% section numbers in margins:
\renewcommand\sectionlinesformat[4]{\makebox[0pt][r]{#3}#4}

% header & footer
\usepackage{scrlayer-scrpage}
\lofoot{\today}
\refoot{\today}
\pagestyle{scrheadings}

\usepackage[sfdefault,light]{roboto}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage[yyyymmdd]{datetime} % must be after babel
\renewcommand{\dateseparator}{-} % ISO8601 date format
\usepackage{hyperref}
\usepackage{bbm}
\usepackage{amsmath} % for $\text{}$
\usepackage{amssymb}
\usepackage[nameinlink]{cleveref}
\crefname{figure}{Abb}{Abb}
\usepackage[section]{placeins}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{float} % für Fließumgebungen; Platzierung H verschiebt nicht
\usepackage{multirow}
\restylefloat{figure}
\hypersetup{
	pdftitle={Pflichtenheft},
	bookmarks=true,
}
\usepackage{csquotes}

\newcommand\urlpart[2]{$\underbrace{\text{\texttt{#1}}}_{\text{#2}}$}

\usepackage{pflichtenheft}

\usepackage[nonumberlist]{glossaries}

\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}

\begin{document}
\section{Einleitung}
TODO

\section{Pakete und Klassen}
\subsection{Paket \texttt{edu.kit.loop.model}}
Das Modell beinhaltet Klassen und Methoden zum Starten und Abbrechen von Simulationen, sowie zum Erstellen und Speichern von Konfigurationen, Stufenspielen, Strategien und Populationen.

\subsubsection{Class \texttt{UserConfiguration}}
//vielleicht im falschen Package

Diese Klasse repräsentiert eine vom Nutzer erstellte Konfiguration. Sie bietet Methoden zum Lesen aller zugehörigen Parameter.

Konstruktoren:

Methoden:

\subsubsection{Class \texttt{Configuration}}
Diese Klasse repräsentiert die elementare Konfiguration einer einzelnen Wiederholung und enthält alle Informationen zum Start einer solchen:
\begin{itemize}\itemsep -10pt
\item Stufenspiel
\item Anzahl von Agenten
\item Runden pro Adaptionsschritt
\item Ob gemischte Strategien zugelassen sind
\item Gruppen-/Segmenteinteilungen
\item Kapital- und Strategieinitialisierung der Segmente
\item Agentenpaarung
\item Erfolgsquantifizierung
\item Adaptionsmechanismus
\item Gleichgewichtskriterium
\item Maximale Zahl von Adaptionsschritten
\end{itemize}

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Configuration(Game game, int roundCount, boolean mixedStrategies, Collection<Segment> segments, PairBuilder pairBuilder, SuccessQuantifier successQuantifier, SrategyAdjuster strategyAdjuster, EquilibriumCriterion equilibriumCriterion, int maxAdapts)}
\item[] Erstellt eine neue \texttt{Configuration} mit den gegebenen Parametern.
\item[] \texttt{game}: Das Stufenspiel dieser Konfiguration
\item[] \texttt{roundCount}: die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration
\item[] \texttt{mixedStrategies}: gibt an, ob gemischte Strategien in dieser Konfiguration erlaubt sind
\item[] \texttt{segments}: alle Segmente dieser Konfiguration
\item[] \texttt{pairBuilder}: Der Paarbildungsalgorithmus dieser Konfiguration
\item[] \texttt{successQuantifier}: die Erfolgsquantifizierung dieser Konfiguration
\item[] \texttt{strategyAdjuster}: der Adaptionsmechanismus dieser Konfiguration
\item[] \texttt{equilibriumCriterion}: das Gleichgewichtskriterium dieser Konfiguration
\item[] \texttt{maxAdapts}: die maximale Zahl durchzuführender Adaptionsschritte dieser Konfiguration
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Game getGame()}
\item[] Gibt das Stufenspiel dieser Konfiguration zurück.
\item[] Returns: das Stufenspiel dieser Konfiguration

\item \texttt{int getAgentCount()}
\item[] Gibt die Anzahl von Agenten in dieser Konfiguration zurück.
\item[] Returns: die Anzahl von Agenten in dieser Konfiguration

\item \texttt{int getRoundCount()}
\item[] Gibt die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration zurück.
\item[] Returns: die Anzahl von Runden pro Adaptionsschritt in dieser Konfiguration

\item \texttt{boolean allowsMixedStrategies()}
\item[] Gibt zurück, ob in dieser Konfiguration gemischte Strategien zugelassen sind.
\item[] Returns: \texttt{true}, falls in dieser Konfiguration gemischte Strategien zugelassen sind; \texttt{false} sonst

\item \texttt{Collection<Segment> getSegments()}
\item[] Gibt alle zu dieser Konfiguration gehörenden Segmente zurück.
\item[] Returns: eine \texttt{Collection} aller \texttt{Segment}e dieser Konfiguration

\item \texttt{PairBuilder getPairBuilder()}
\item[] Gibt den Paarbildungsalgorithmus dieser Konfiguration zurück.
\item[] Returns: den Paarbildungsalgorithmus dieser Konfiguration

\item \texttt{SuccessQuantifier getSuccessQuantifier()}
\item[] Gibt die Erfolgsquantifizierung dieser Konfiguration zurück.
\item[] Returns: die Erfolgsquantifizierung dieser Konfiguration

\item \texttt{StrategyAdjuster getStrategyAdjuster()}
\item[] Gibt den Adaptionsmechanismus dieser Konfiguration zurück.
\item[] Returns: den Adaptionsmechanismus dieser Konfiguration

\item \texttt{EquilibriumCriterion getEquilibriumCriterion()}
\item[] Gibt das Gleichgewichtskriterium dieser Konfiguration zurück.
\item[] Returns: das Gleichgewichtskriterium dieser Konfiguration

\item \texttt{int getMaxAdapts()}
\item[] Gibt die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration zurück.
\item[] Returns: die maximale Zahl durchzuführender Adaptionsschritte für diese Konfiguration
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.simulator}}
Dieses Paket enthält das Interface \texttt{Simulator}. Dieses bietet eine Schnittstelle zum Starten und Abbrechen von Simulationen. Beim Start einer Simulation wird eine Referenz auf ein \texttt{Simulation}-Objekt zurückgegeben, über das der Ausführungsstatus und die Ergebnisse der Simulation abgefragt werden können.

\subsubsection{Class \texttt{Simulation}}
Ein \texttt{Simulation}-Objekt enthält Informationen zu einer gestarteten Simulation, etwa deren Konfiguration, Ausführungsstatus, \texttt{id} und gegebenenfalls die Ergebnisse der Simulation. Es wird von einem \texttt{Simulator} erzeugt und bereitgestellt, wenn eine Simulation gestartet wird.

Die Klasse unterscheidet nicht zwischen Multikonfigurationen und Nicht-Multikonfigurationen, geht also allgemein von mehreren zugrundeliegenden elementaren Konfigurationen aus.

Konstruktoren:
\begin{itemize} \itemsep -10pt
\item \texttt{Simulation(UserConfiguration config, int id)}
\item[] Erzeugt ein neues \texttt{Simulation}-Objekt mit der gegebenen \texttt{UserConfiguration} und der gegebenen \texttt{id}.
\item[] \texttt{config}: die Konfiguration der Simulation
\item[] \texttt{id}: die \texttt{id} dieser Simulation
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{protected void addIterationResult(IterationResult result, int i)}
\item[] Fügt ein Wiederholungsergebnis zur \texttt{i}-ten elementaren Konfiguration dieser Simulation als \texttt{IterationResult} hinzu.
\item[] \texttt{result}: das Wiederholungsergebnis, das hinzugefügt werden soll
\item[] \texttt{i}: die elementare Konfiguration, zu der das Wiederholungsergebnis hinzugefügt werden soll

\item \texttt{void registerIterationFinished(Consumer<IterationResult> action)}
\item[] Registriert eine Aktion, die jedes mal ausgeführt wird, wenn eine Wiederholung dieser Simulation abgeschlossen wird. Der Aktion wird als Argument das Ergebnis der Wiederholung als \texttt{IterationResult} übergeben.
\item[] \texttt{action}: Die Aktion, die bei Abschluss jeder Wiederholung dieser Simulation ausgeführt werden soll

\item \texttt{List<IterationResult> getIterationResults(int i)}
\item[] Gibt eine Liste der Wiederholungsergebnisse der bisher abgeschlossenen Wiederholungen mit der \texttt{i}-ten zugrundeliegenden elementaren Konfiguration als \texttt{IterationResult}s zurück.
\item[] \texttt{i}: die elementare Konfiguration, zu der die Wiederholungsergebnisse zurückgegeben werden sollen
\item[] Returns: die Wiederholungsergebnisse der bisher abgeschlossenen Wiederholungen mit der \texttt{i}-ten zugrundeliegenden elementaren Konfiguration

\item \texttt{UserConfiguration getUserConfiguration()}
\item[] Gibt die \texttt{UserConfiguration} dieser Simulation zurück.
\item[] Returns: die \texttt{UserConfiguration} dieser Simulation

\item \texttt{int getConfigurationCount()}
\item[] Gibt die Zahl der dieser Simulation zugrundeliegenden elementaren Konfigurationen zurück. Im Falle einer Multikonfiguration also die Anzahl verschiedener Werte des Multikonfigurationsparameters, ansonsten \(1\).
\item[] Returns: die Zahl der dieser Simulation zugrundeliegenden elementaren Konfigurationen

\item \texttt{int getId()}
\item[] Gibt die \texttt{id} dieser Simulation zurück.
\item[] Returns: die \texttt{id} dieser Simulation
\end{itemize}

\subsubsection{Interface \texttt{Simulator}}
Über einen Simulator können Simulationen gestartet und abgebrochen werden. Zum Starten einer Simulation muss dem \texttt{Simulator} eine \texttt{UserConfiguration} übergeben werden, die die durchzuführende Simulation spezifiziert. Daraufhin wird ein \texttt{Simulation}-Objekt erzeugt und zurückgegeben, über das der Ausführungsstatus und die Ergebnisse der gestarteten Simulation abgefragt werden können. Jeder Simulation wird beim Start eine eindeutige \texttt{id} zugewiesen.

Methoden:
\begin{itemize} \itemsep -10pt
\item \texttt{Simulation startSimulation(UserConfiguration config)}
\item[] Startet eine Simulation mit der gegebenen \texttt{UserConfiguration} und gibt ein \texttt{Simulation}-Objekt zu der gestarteten Simulation zurück.
\item[]\texttt{config}: die Konfiguration, mit der die Simulation ausgeführt werden soll
\item[] Returns: ein \texttt{Simulation}-Objekt zu der gestarteten Simulation

\item \texttt{Simulation startSimulation(UserConfiguration config, Consumer<Simulation> action)}
\item[] Startet eine Simulation mit der gegebenen Konfiguration und gibt ein \texttt{Simulation}-Objekt zu der gestarteten Simulation zurück. Führt die gegebene Aktion mit der zurückgegebenen \texttt{Simulation} als Argument aus, sobald die Ausführung der Simulation abgeschlossen ist.
\item[] \texttt{config}: die Konfiguration, mit der die Simulation ausgeführt werden soll
\item[] \texttt{action}: Die Aktion, die ausgeführt werden soll, sobald die Simulation abgeschlossen ist
\item[] Returns: ein \texttt{Simulation}-Objekt zu der gestarteten Simulation

\item \texttt{boolean stopSimulation(Simulation sim)}
\item[] Falls die gegebene Simulation aktuell läuft, wird diese abgebrochen und \texttt{true} zurückgegeben. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{sim}: Die Simulation, die abgebrochen werden soll
\item[] Returns: \texttt{true}, wenn die Simulation erfolgreich abgebrochen wurde, \texttt{false} sonst

\item \texttt{boolean stopSimulation(int id)}
\item[] Falls eine Simulation mit der gegebenen \texttt{id} läuft, wird diese abgebrochen und \texttt{true} zurückgegeben. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{id}: Die \texttt{id} der Simulation, die abgebrochen werden soll
\item[] Returns: \texttt{true}, wenn die Simulation erfolgreich abgebrochen wurde, \texttt{false} sonst

\item \texttt{void stopAllSimulation()}
\item[] Bricht die Ausführung aller gestarteten Simulationen ab.

\item \texttt{Simulation getSimulation(int id)}
\item[] Gibt das \texttt{Simulation}-Objekt der Simulation mit der entsprechenden \texttt{id} zurück, falls existent. Ansonsten \texttt{null}.
\item[] \texttt{id}: Die \texttt{id} der Simulation, deren \texttt{Simulation}-Objekt zurückgegeben werden soll
\item[] Returns: das \texttt{Simulation}-Objekt der Simulation mit der entsprechenden \texttt{id}, falls existent. Ansonsten \texttt{null}.
\end{itemize}

\subsubsection{Class \texttt{ThreadPoolSimulator}}
Implements: \texttt{Simulator}

Eine Implementierung des \texttt{Simulator}-Interfaces. Führt die Wiederholungen parallel in einem \texttt{ThreadPool} aus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ThreadPoolSimulator()}
\item[] Erzeugt einen neuen \texttt{ThreadPoolSimulator}.

\item \texttt{ThreadPoolSimulator(int maxThreads)}
\item[] Erzeugt einen neuen \texttt{ThreadPoolSimulator} mit der gegebenen maximalen Anzahl von \texttt{Thread}s.
\item[] \texttt{maxThreads}: die maximale Anzahl von \texttt{Thread}s im \texttt{ThreadPool}
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getRunningIterationCount()}
\item[] Gibt die Zahl aktuell ausgeführter Wiederholungen zurück.
\item[] Returns: die Zahl aktuell ausgeführter Wiederholungen

\item \texttt{int getQueuedIterationCount()}
\item[] Gibt die Zahl aktuell auf Ausführung wartender Wiederholungen zurück.
\item[] Returns: die Zahl aktuell auf Ausführung wartender Wiederholungen
\end{itemize}

\subsubsection{Class \texttt{ConfigurationCreator}}
Diese Klasse nimmt eine \texttt{UserConfiguration} entgegen und extrahiert daraus alle zugehörigen elementaren Konfigurationen. Diese werden als \texttt{Configuration}s zurückgegeben.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ConfigurationCreator()}
\item[] Erzeugt einen neuen \texttt{ConfigurationCreator}.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Configuration> generateConfigurations(UserConfiguration config)}
\item[] Erzeugt alle zu der gegebenen \texttt{UserConfiguration} gehörigen elementaren Konfigurationen und gibt sie als \texttt{Configuration}s zurück.
\item[] \texttt{config}: Die \texttt{UserConfiguration}, zu der alle elementaren Konfigurationen generiert werden sollen
\item[] Returns: alle zu der gegebenen \texttt{UserConfiguration} gehörigen elementaren Konfigurationen als \texttt{Configuration}s
\end{itemize}

\subsection{Paket \texttt{edu.kit.loop.model.simulationengine}}

Dieses Paket beinhaltet die Klasse \texttt{SimulationEngine}, mit der eine einzelne Wiederholung zu einer bestimmten elementaren Konfiguration ausgeführt werden kann.

\subsubsection{Class \texttt{AgentInitializer}}
Ein \texttt{AgentInitializer} kann verwendet werden, um die Agenten eines gegebenen Segments zu erstellen und mit Kapital, Strategien und Gruppenzugehörigkeit zu initialisieren.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{AgentInitializer()}
\item[] Erzeugt einen neuen \texttt{AgentInitializer}.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Collection<Agent> initializeAgents(Segment segment)}
\item[] Erzeugt die Agenten des gegebenen Segments und initialisiert sie mit Kapital, Strategien und Gruppenzugehörigkeiten. Gibt die Agenten als \texttt{Collection} zurück.
\item[] Returns: die initialisierten Agenten als \texttt{Collection}
\end{itemize}

\subsubsection{Interface \texttt{SimulationHistory}}
Eine Implementierung des \texttt{SimulationHistory}-Interfaces speichert für jeden Agenten die Ergebnisse aller bisherigen Runden eines Adaptionsschrittes.

Methoden:
\begin{itemize}\itemsep -10pt
	\item \texttt{void addResult(GameResult result)}
	\item[] Fügt der Historie ein neues Rundenergebnis hinzu.
	\item[] \texttt{result}: Das \texttt{GameResult}, das zur Historie hinzugefügt werden soll
	\item \texttt{List<GameResult> getAllResults()}
	\item[]Gibt alle Rundenergebnisse  aller Agenten als Liste zurück.
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{List<GameResult> getResultsByAgent(agent: Agent)}
	\item[]Gibt alle Rundenergebnisse des gegebenen Agenten als Liste zurück.
	\item[] \texttt{agent}: Der Agent dessen Ergebnisse abgefragt werden
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{List<GameResult> getLatestResults()}
	\item[]Gibt das letzte Rundenergebnis aller Agenten als Liste zurück.
	\item[]Returns: Die Liste der Rundenergebnisse
	\item \texttt{GameResult getLatestResultByAgent(agent: Agent)}
	\item[] Gibt das letzte Rundenergebnis des gegebenen Agenten zurück.
	\item[] \texttt{agent}: Der Agent dessen letztes Ergebnis abgefragt wird
	\item[]Returns: Das letzte RundenErgebnis des Agenten als \texttt{GameResult}
	\item \texttt{Iterable<GameResult> getAllWhere(condition: Predicate<GameResult>)}
	\item[] Filtert alle Rundenergebnisse gemäß einer gegebenen Filterbedingung und liefert sie in Form eines \texttt{Iterable} zurück.
	\item[]\texttt{condition}: Die Filterbedinung als Prädikat mit einem \texttt{GameResult} als Parameter.
	\item[]Returns: Die gefilterten Rundenergebnisse als \texttt{Iterable}
	\item \texttt{GameResult getLatestWhere(condition: Predicate<GameResult>)}
	\item[] Filtert alle Rundenergebnisse gemäß einer gegebenen Filterbedingung und liefert das letzte Rundenergebnis, welches die Bedingung erfüllt zurück.
	\item[]\texttt{condition}: Die Filterbedinung als Prädikat mit einem \texttt{GameResult} als Parameter.
	\item[]Returns: Das letzte Rundenergebnis, welches die Filterbedingung erfüllt
\end{itemize}

\subsubsection{Class \texttt{SimulationHistoryTable}}
Implements: \texttt{SimulationHistory}

Diese Klasse implementiert das \texttt{SimulationHistory}-Interface.

\subsection{Paket \texttt{edu.kit.loop.model.simulationengine.core}}
Dieses Paket beinhaltet für den Simulationsablauf zentrale Klassen wie den \texttt{Agent}, das Stufenspiel (\texttt{Game}) oder die \texttt{Strategy}.

\subsubsection{Class \texttt{Agent}}
Diese Klasse repräsentiert einen einzelnen Agenten in einem Simulationsdurchlauf. Sie enthält Informationen über den Agenten wie dessen Gruppenzugehörigkeit, sein aktuelles und initiales Kapital oder seine aktuelle Strategie.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{Agent(int initialCapital, Strategy initialStrategy, int groupId)}
\item[] Erstellt einen neuen Agenten mit gegebenem Anfangskapital, gegebener Strategie und gegebener Gruppenzugehörigkeit
\item[] \texttt{initialCaptial}: das initiale Kapital des Agenten
\item[] \texttt{initialStrategy}: die initiale Strategie des Agenten
\item[] \texttt{groupId}: die \texttt{id} der Gruppe, der dieser Agent zugehörig ist; \(-1\), falls dieser Agent gruppenlos ist.
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getCapital()}
\item[] Gibt das aktuelle Kapital des Agenten zurück.
\item[] Returns: das aktuelle Kapital des Agenten

\item \texttt{int getInitialCapital()}
\item[] Gibt das initiale Kapital des Agenten zurück.
\item[] Returns: das initiale Kapital des Agenten

\item \texttt{void addCapital(int capital)}
\item[] Erhöht das Kapital des Agenten um den gegebenen Wert.

\item \texttt{Strategy getStrategy()}
\item[] Gibt die aktuelle Strategie des Agenten zurück.
\item[] Returns: die aktuelle Strategie des Agenten

\item\texttt{void setStrategy(Strategy strategy)}
\item[] Setze die Strategie des Agenten auf die gegebene Strategie.

\item \texttt{int getGroupId()}
\item[] Gibt die \texttt{id} der Gruppe zurück, der dieser Agent zugehörig ist bzw. \(-1\) falls er gruppenlos ist.
\item[] Returns: die \texttt{id} der Gruppe zurück, der dieser Agent zugehörig ist bzw. \(-1\) falls er gruppenlos ist.
\end{itemize}

\subsubsection{Class \texttt{GameResult}}

Diese Klasse speichert das Ergebnis eines Spiels zwischen zwei Agenten. Das Ergebnis besteht aus:
\begin{itemize}\itemsep -10pt
	\item Den beteiligten Agenten
	\item Den Aktionen der beteiligten Agenten
	\item Den erhaltenen Auszahlungen der Agenten
\end{itemize}
	
Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{GameResult(Agent player1, Agent player2, int payOff1, int payOff2, boolean hasCooperated1, boolean hasCooperated2)}
\item[] Erzeugt ein neues \texttt{GameResult}-Objekt.
\item[] \texttt{player1}: der erste Spieler
\item[] \texttt{player2}: der zweite Spieler
\item[] \texttt{payOff1}: die erhaltene Auszahlung des ersten Spielers
\item[] \texttt{payOff2}: die erhaltene Auszahlung des zweiten Spielers
\item[] \texttt{hasCooperated1}: \texttt{true}, falls der erste Spieler kooperiert hat; \texttt{false} sonst
\item[] \texttt{hasCooperated2}: \texttt{true}, falls der zweite Spieler kooperiert hat; \texttt{false} sonst
\end{itemize}

Methoden:
\begin{itemize}\itemsep -10pt
\item  \texttt{boolean hasAgent(Agent agent)}
\item[] Gibt zurück, ob der gegebene Agent einer der beiden Spieler dieses Spiels war.
\item[] \texttt{agent}: der Agent, für den geprüft werden soll, ob er Spieler dieses Spiels war
\item[] Returns: \texttt{true}, falls der gegebene Agent einer der beiden Spieler dieses Spiels war; \texttt{false} sonst

\item \texttt{int getPayoff(Agent agent)}
\item[] Gibt die Auszahlung zurück, die der gegebene Agent bei diesem Spiel erhalten hat, falls er beteiligt war; andernfalls wird \(0\) zurückgegeben.
\item[] \texttt{agent}: der Agent, dessen Auszahlung zurückgegeben werden soll
\item[] Returns: die erhaltene Auszahlung des gegebenen Agenten, falls er beteiligt war; andernfalls \(0\)

\item \texttt{boolean hasCooperated(Agent agent)}
\item[] Gibt zurück, ob der gegebene Agent in diesem Spiel kooperiert hat, falls er beteiligt war. Andernfalls wird \texttt{false} zurückgegeben.
\item[] \texttt{agent}: der Agent, für den zurückgegeben werden soll, ob er kooperiert hat
\item[] Returns: \texttt{true}, falls der gegebene Agent an diesem Spiel beteiligt war und kooperiert hat, andernfalls \texttt{false}

\item \texttt{Collection<Agent> getAgents()}
\item[] Gibt die beiden an diesem Spiel beteiligten Agenten zurück.
\item[] Returns: die beiden an diesem Spiel beteiligten Agenten als \texttt{Collection<Agent>}
\end{itemize}

\subsubsection{Interface \texttt{Game}}
Dieses Interface repräsentiert ein Stufenspiel.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{String getName()}
\item[] Gibt den Namen des Stufenspiels zurück.
\item[] Returns: den Namen des Stufenspiels

\item \texttt{String getDescription()}
\item[] Gibt die Beschreibung dieses Stufenspiels zurück.
\item[] Returns: die Beschreibung dieses Stufenspiels

\item[] \texttt{GameResult play(boolean playerOneCooperates, boolean playerTwoCooperates)}
\item[] Lässt zwei Spieler mit gegebenen Kooperationsentscheidungen dieses Stufenspiel spielen und gibt das Ergebnis des Spiels als \texttt{GameResult}-Objekt zurück.
\item[] \texttt{playerOneCooperates}: \texttt{true}, falls der erste Spieler kooperiert; \texttt{false sonst}
\item[] \texttt{playerTwoCooperates}: \texttt{true}, falls der zweite Spieler kooperiert; \texttt{false sonst}
\item[] Returns: das Ergebnis des Spiels als \texttt{GameResult}-Objekt
\end{itemize}

\subsubsection{Interface \texttt{Strategy}}
Repräsentiert eine Strategie. Diese kann, aber muss nicht gemischt sein.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{boolean isCooperative(Agent player, Agent opponent, SimulationHistory history)}
\item[] Gibt zurück, ob der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde. Ist die Strategie gemischt, wird entsprechend ein zufälliges Ergebnis ausgegeben.
\item[] Returns: ob der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde

\item \texttt{double getCooperationProbability(Agent player, Agent opponent, SimulationHistory history)}
\item[] Gibt die Wahrscheinlichkeit zurück, mit der der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde.
\item[] Returns: die Wahrscheinlichkeit, mit der der Agent \texttt{player} bei einem Spiel gegen den Agenten \texttt{opponent} bei Benutzung dieser Strategie bei gegebenem bisherigen Simulationsverlauf kooperieren würde
\end{itemize}

\subsubsection{Class \texttt{PureStrategy}}
Implements: \texttt{Strategy}

Diese Klasse repräsentiert eine reine Strategie. Diese ist eindeutig bestimmt durch eine Bedingung an den gegnerischen Agenten basierend auf dem bisherigen Verlauf der Simulation, repräsentiert als \texttt{Predicate<Agent,SimulationHistory>}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PureStrategy(Predicate<Agent,SimulationHistory> condition)}
\item[] Erzeugt ein neues \texttt{PureStrategy}-Objekt.
\item[] \texttt{condition}: die Bedingung an den gegnerischen Agenten, unter der ein Agent bei Verwendung dieser Strategie kooperiert
\end{itemize}

\subsubsection{Class \texttt{CustomStrategy}}
//vorläufig

\subsubsection{Class \texttt{MixedStrategy}}
Implements: \texttt{Strategy}

Diese Klasse repräsentiert eine gemischte Strategie, die sich aus mehreren \texttt{PureStrategie}s zusammensetzt.

Konstruktoren://vorläufig
\begin{itemize}\itemsep -10pt
\item[] //wirft exception wenn listen nicht gleichlang oder wahrsch. ungültig (alle positiv und in summe 1)
\item \texttt{MixedStrategy(List<PureStrategies> pureStrategies, List<Integer> probabilites)}
\item[] Erstellt eine neue \texttt{MixedStrategy}, die aus den gegebenen reinen Strategien mit den gegebenen Wahrscheinlichkeiten besteht.
\item[] \texttt{pureStrategies}: die reinen Strategien, aus denen diese Strategie besteht
\item[] \texttt{probabilities}: die Wahrscheinlichkeiten der gegebenen reinen Strategien
\end{itemize}

\subsubsection{Class \texttt{Segment}}
//umbenennen!
Diese Klasse repräsentiert ein Segment. Dieses wird charakterisiert durch die Anzahl zugehöriger Agenten, die \texttt{id} der Gruppe, zu der das Segment gehört sowie initiale Kapital- und Strategieverteilung.

Konstruktoren:

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{int getAgentCount()}
\item[] Gibt die Anzahl der Agenten in diesem Segment zurück.
\item[] Returns: die Anzahl der Agenten in diesem Segment

\item \texttt{int getGroupId()}
\item[] Gibt die \texttt{id} der Gruppe zurück, zu der dieses Segment gehört bzw. \(-1\), falls es zu den gruppenlosen Agenten gehört.
\item[]die \texttt{id} der Gruppe, zu der dieses Segment gehört bzw. \(-1\), falls es zu den gruppenlosen Agenten gehört

\item \texttt{CapitalDistribution getCapitalDistribution()}
//vorläufig
\item \texttt{StrategyDistribution getStrategyDistribution()}
//vorläufig
\end{itemize}

\subsubsection{Interface \texttt{PairBuilder}}
Dieses Interface repräsentiert einen Paarbildungsalgorithmus. Eine Implementierung nimmt eine Menge von Agenten sowie den bisherigen Verlauf des aktuellen Adaptionsschritts in Form eines \texttt{SimulationHistory}-Objektes entgegen und gibt ein Matching der Agenten zurück.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{Collection<AgentPair> buildPairs(Collection<Agent> agents, SimulationHistory history)}
\item[] Fasst die gegebene Menge von Agenten zu Paaren zusammen und gibt diese als \texttt{Collection} von \texttt{AgentPair}s zurück.
\item[] \texttt{agents}: die Agenten, aus denen Paare gebildet werden sollen
\item[] \texttt{history}: der bisherige Verlauf des Adaptionsschritts
\item[] Returns: die gebildeten Paare als \texttt{Collection<AgentPair>}
\end{itemize}

\subsubsection{Class \texttt{RandomPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die zufällige Paarbildung von Agenten.

\subsubsection{Class \texttt{CooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die in der Spezifikation beschriebene \enquote{Paarbildung nach Wunsch}.

\subsubsection{Class \texttt{RandomCooperationConsideringPairBuilder}}
Implements: \texttt{PairBuilder}

Realisiert die in der Spezifikation beschriebene \enquote{Paarbildung nach Wunsch mit Zufall}.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{RandomCooperationConsideringPairBuilder(double randomnessFactor)}
\item[] Erstellt einen neuen \texttt{RandomCooperationConsideringPairBuilder}.
\item[] \texttt{randomnessFactor}: der Zufallsfaktor für die Paarbildung; zwischen \(0\) und \(1\)
\end{itemize}

\subsubsection{Interface \texttt{SuccessQuantifier}}
Dieses Interface repräsentiert eine Erfolgsquantifizierung. Eine Implementierung nimmt eine Menge von Agenten sowie den bisherigen Verlauf des aktuellen Adaptionsschritts in Form eines \texttt{SimulationHistory}-Objektes entgegen und erstellt eine Rangliste der Agenten anhand deren Erfolg in den vergangenen Runden. Diese wird als Liste zurückgegeben.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{List<Agent> createRanking(Collection<Agent> agents, SimulationHistory history)}
\item[] Erstellt eine Rangliste der gegebenen Agenten und gibt diese als Liste zurück.
\item[] \texttt{agents}: die Agenten, aus denen eine Rangliste erstellt werden soll
\item[] \texttt{history}: der bisherige Verlauf des aktuellen Adaptionsschritts
\item[] Returns: die erstellte Rangliste als \texttt{List<Agent>}
\end{itemize}

\subsubsection{Class \texttt{TotalCapital}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Absolutkapital}-Erfolgsquantifizierung

\subsubsection{Class \texttt{TotalPayoff}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Absolutkapital ohne Initialkapital}-Erfolgsquantifizierung.

\subsubsection{Class \texttt{SlidingMean}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Gleitender Durchschnitt}-Erfolgsquantifizierung.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{SlidingMean(int windowSize)}
\item[] Erstellt ein neues \texttt{SlidingMean}-Objekt mit der gegebenen Fenstergröße.
\item[] \texttt{windowSize}: die Fenstergröße für die Durchschnittsberechnung
\end{itemize}

\subsubsection{Class \texttt{PayoffInLastAdapt}}
Implements: \texttt{SuccessQuantifier}

Realisiert die in der Spezifikation beschriebene \enquote{Auszahlung im letzten Adaptionsschritt}-Erfolgsquantifizierung.

\subsubsection{Interface \texttt{StrategyAdjuster}}
Dieses Interface repräsentiert einen Adaptionsmechanismus. Eine Implementierung nimmt eine nach Rang geordnete Liste von Agenten entgegen und passt die Strategien der Agenten an.

Methoden:
\begin{itemize}\itemsep -10pt
\item \texttt{void adaptStrategies(List<Agent> agents)}
\item[] Adaptiert die Strategien der gegebenen Agenten.
\item[] \texttt{agents}: die Agenten, deren Strategien adaptiert werden sollen, geordnet nach Erfolg im aktuellen Adaptionsschritt
\end{itemize}

\subsubsection{Class \texttt{ReplicatorDynamic}}
Implements: \texttt{StrategyAdjuster}

Realisiert den in der Spezifikation beschriebenen \enquote{Replicator Dynamic}-Anpassungsmechanismus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{ReplicatorDynamic(double alpha, double delta)}
\item[] Erstellt ein neues \texttt{ReplicatorDynamic}-Objekt mit den gegebenen Parametern \(\alpha\) und \(\delta\).
\item[] \texttt{alpha}: die Vergleichswahrscheinlichkeit
\item[] \texttt{delta}: die Anpassungswahrscheinlichkeit
\end{itemize}

\subsubsection{Class \texttt{PreferentialAdaption}}
Implements: \texttt{StrategyAdjuster}

Realisiert den in der Spezifikation beschriebenen \enquote{Preferential Adaption}-Anpassungsmechanismus.

Konstruktoren:
\begin{itemize}\itemsep -10pt
\item \texttt{PreferentialAdaption(double alpha, double delta)}
\item[] Erstellt ein neues \texttt{PreferentialAdaption}-Objekt mit den gegebenen Parameter \(\alpha\) und \(\delta\).
\item[] \texttt{alpha}: die Vergleichswahrscheinlichkeit
\item[] \texttt{delta}: die Anpassungswahrscheinlichkeit
\end{itemize}

\subsubsection{Interface \texttt{EquilibriumCriterion}}
//vorläufig, morgen (5.12.) besprechen! siehe UML-Diagramm\\
Dieses Interface repräsentiert ein Gleichgewichtskriterium. Eine Implementierung nimmt nach jeder Runde mittels \texttt{boolean isEquilibrium(...)} eine nach aktuellem Rang geordnete Liste von Agenten entgegen und gibt zurück, ob sich ein Gleichgewicht eingestellt hat. Um aufeinanderfolgende Runden vergleichen zu können, muss eine Implementierung stets die Agentenliste des vorhergehenden Aufrufs von \texttt{isEquilibrium(...)} speichern.

\section{Glossar}
\textbf{Elementare Konfiguration:}
Eine Konfiguration, in der Multikonfiguration deaktiviert ist. Mit den \enquote{einer Konfiguration zugehörigen elementaren Konfigurationen} wird im Falle einer Multikonfiguration die Menge aller elementaren Konfigurationen bezeichnet, in denen der Multikonfigurationsparameter die festgelegte Wertemenge durchläuft. Im Falle einer elementare Konfiguration ist wieder die Konfiguration selbst gemeint.

\end{document}
